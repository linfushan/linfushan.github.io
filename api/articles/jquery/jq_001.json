{"title":"JQuery 插件封装","uid":"58f8583587853300427967dcc2c71efb","slug":"jquery/jq_001","date":"2023-05-23T02:35:56.520Z","updated":"2023-06-18T12:56:10.120Z","comments":true,"path":"api/articles/jquery/jq_001.json","keywords":null,"cover":"../../images/jquery/jquery.jpg","content":"<ul>\n<li></li>\n</ul>\n<h1 id=\"jQuery-的开发方式\"><a href=\"#jQuery-的开发方式\" class=\"headerlink\" title=\"jQuery 的开发方式\"></a>jQuery 的开发方式</h1><ol>\n<li>通过<code>$.extend()</code>来扩展jQuery</li>\n<li>通过<code>$.fn</code>向jQuery添加新方法</li>\n<li>通过<code>$.widget()</code>应用jQuery UI的部件工厂方式创建</li>\n</ol>\n<h1 id=\"写在哪里\"><a href=\"#写在哪里\" class=\"headerlink\" title=\"写在哪里\"></a>写在哪里</h1><p>写插件一般都是单独的一个文件出来，然后可重复的供他人调用。由于插件依赖的是jQuery，所以在写插件的时候需要避免一些不必要的冲突和一些兼容的问题，所以就有了一下的一种安全的结构。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">;(function($,window,document,undefined)&#123;\n    &#x2F;&#x2F;CODE HERE\n&#125;)(jQuery,window,document);</code></pre>\n\n<h1 id=\"extend\"><a href=\"#extend\" class=\"headerlink\" title=\"$.extend()\"></a>$.extend()</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>第一种方式很简单，仅仅是在jQuery命名空间或者理解成jQuery身上添加了一个静态方法而以。所以我们调用通过$.extend()添加的函数时直接通过$符号调用（$.myfunction()）而不需要选中DOM元素($(‘#example’).myfunction())。</p></blockquote>\n<p>例子：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">$.extend(&#123;\n    sayHello: function(name) &#123;\n        console.log(&#39;Hello,&#39; + (name ? name : &#39;Dude&#39;) + &#39;!&#39;);\n    &#125;\n&#125;)\n$.sayHello(); &#x2F;&#x2F;调用\n$.sayHello(&#39;Linfs&#39;); &#x2F;&#x2F;带参调用</code></pre>\n\n<p>运行结果：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Hello,Dude!<br>Hello,Linfs</p></blockquote>\n<p>第一种方式很简单，但是也有很大的局限性。这种方式无法利用jQuery强大的选择器带来的便利，要处理DOM元素以及将插件更好地运用于所选择的元素身上，还是需要使用第二种开发方式</p>\n<h1 id=\"fn\"><a href=\"#fn\" class=\"headerlink\" title=\"$.fn\"></a>$.fn</h1><h2 id=\"基本格式\"><a href=\"#基本格式\" class=\"headerlink\" title=\"基本格式\"></a>基本格式</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">$.fn.pluginName &#x3D; function()&#123;\n    &#x2F;&#x2F;CODE HERE\n&#125;</code></pre>\n\n<h2 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h2><h3 id=\"给链接上色\"><a href=\"#给链接上色\" class=\"headerlink\" title=\"给链接上色\"></a>给链接上色</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">$.fn.greenify &#x3D; function() &#123;\n    this.css( &quot;color&quot;, &quot;green&quot; );\n&#125;;\n&#x2F;&#x2F; 调用\n$( &quot;a&quot; ).greenify();</code></pre>\n\n<p>通过以上的插件方法就可以把所有的链接变成绿色了。</p>\n<p>插件里面的<code>this</code>主要代表的就是<strong>所选元素的一个集合</strong>，也就是<code>$(&quot;a&quot;)</code>，即this&#x3D;$(“a”),相当于<code>$(&quot;a&quot;).css( &quot;color&quot;, &quot;green&quot; )</code>。</p>\n<p>上面说了<code>this</code>是所选元素的一个集合，但是有时候并不需要对所有的元素进行同样的操作，所以接下来将处理集合中的每个元素。</p>\n<h3 id=\"each\"><a href=\"#each\" class=\"headerlink\" title=\"each()\"></a>each()</h3><p>使用jQuery中的each()对集合中的元素进行操作，这时候each()内部的this指带的是普通的DOM元素了，如果需要调用jQuery的方法那就需要用$来重新包装一下</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">;(function($,window,document,undefined)&#123;\n    var colorArr &#x3D; [&quot;#3793e2&quot;,&quot;#5ab55a&quot;,&quot;#cc3f65&quot;,&quot;#a526cb&quot;];\n    $.fn.changeColor &#x3D; function()&#123;\n        this.each(function()&#123;\n            var i &#x3D; Math.round(Math.random()*(colorArr.length-1));\n            $(this).css(&#123;&quot;color&quot;:colorArr[i]&#125;);\n        &#125;);\n    &#125;\n&#125;)(jQuery,window,document);\n\n&#x2F;&#x2F;调用\n$(&quot;a&quot;).changeColor();</code></pre>\n\n<p>运行结果：<br><img src=\"/images/jquery/20170914143934.png\"></p>\n<p>这样就随机的给每一条链接配上颜色，而不是同样的颜色。</p>\n<h3 id=\"支持链式调用\"><a href=\"#支持链式调用\" class=\"headerlink\" title=\"支持链式调用\"></a>支持链式调用</h3><p>看到上面的结果，还不是很美观，如果能去掉下划线就ok了。这时候要在原来的基础上调用其它的方法将下划线出去掉，就要用到链式调用了。如果按照刚才的写法是无法完成链式调用的，要让插件不打破这种链式调用，只需return一下即可。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">;(function($,window,document,undefined)&#123;\n    var colorArr &#x3D; [&quot;#3793e2&quot;,&quot;#5ab55a&quot;,&quot;#cc3f65&quot;,&quot;#a526cb&quot;];\n    $.fn.changeColor &#x3D; function()&#123;\n        return this.each(function()&#123;\n            var i &#x3D; Math.round(Math.random()*(colorArr.length-1));\n            $(this).css(&#123;&quot;color&quot;:colorArr[i]&#125;);\n        &#125;);\n    &#125;\n&#125;)(jQuery,window,document);\n\n&#x2F;&#x2F;调用\n$(&quot;a&quot;).changeColor().css(&quot;text-decoration&quot;,&quot;none&quot;);</code></pre>\n\n<p>运行结果：<br><img src=\"/images/jquery/20170914144849.png\"></p>\n<h3 id=\"接收参数\"><a href=\"#接收参数\" class=\"headerlink\" title=\"接收参数\"></a>接收参数</h3><p>这是后你会发现，简单的改变字体的颜色已经满足不了你的需求了，你需要改变更多的元素属性，这时候我们设置更多的属性接收不同的参数来满足需求。<br>看例子：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">;(function($,window,document,undefined)&#123;\n    $.fn.changeColor &#x3D; function(options)&#123;\n        var defauts &#x3D; &#123;\n          &quot;colorArr&quot;:[&#39;#3793e2&#39;,&#39;#5ab55a&#39;,&#39;#cc3f65&#39;,&#39;#a526cb&#39;],\n          &quot;backgroundColor&quot;:&quot;#eee&quot;,\n          &quot;fontSize&quot;:&quot;14px&quot;\n        &#125;;\n&#x2F;&#x2F;      var settings &#x3D; $.extend(defauts,options);\n        var settings &#x3D; $.extend(&#123;&#125;,defauts,options);\n        return this.each(function()&#123;\n            var i &#x3D; Math.round(Math.random()*(settings.colorArr.length-1));\n            $(this).css(&#123;\n                &quot;color&quot;:settings.colorArr[i],\n                &quot;backgroundColor&quot;:settings.backgroundColor,\n                &quot;fontSize&quot;:settings.fontSize\n            &#125;);\n        &#125;);\n    &#125;\n&#125;)(jQuery,window,document);\n&#x2F;&#x2F; 使用默认参数的调用\n$(&quot;a&quot;).changeColor().css(&quot;text-decoration&quot;,&quot;none&quot;);\n&#x2F;&#x2F; 修改默认参数的调用\n$(&quot;a&quot;).changeColor(&#123;\n    &quot;colorArr&quot;:[&#39;#3793e2&#39;,&#39;#5ab55a&#39;,&#39;#cc3f65&#39;,&#39;#a526cb&#39;,&quot;#fcbe16&quot;,&quot;#0afafa&quot;],\n    &quot;backgroundColor&quot;:&quot;#000&quot;,\n    &quot;fontSize&quot;:&quot;16px&quot;\n&#125;).css(&quot;text-decoration&quot;,&quot;none&quot;);</code></pre>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">使用默认参数的调用</th>\n<th align=\"left\">修改默认参数的调用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><img src=\"/images/jquery/20170914151500.png\"></td>\n<td align=\"left\"><img src=\"/images/jquery/20170914152017.png\"></td>\n</tr>\n</tbody></table>\n<p>看完代码会发现有两种接收参数的方式。</p>\n<ol>\n<li><code>var settings = $.extend(defauts,options);</code>这种方式有个特点，就是options带进来的值会覆盖掉defaults的默认值，这样如果需要再调用默认值的话会变成传进来的值。<br><img src=\"/images/jquery/20170914153043.png\"></li>\n<li><code>var settings = $.extend(&#123;&#125;,defauts,options);</code>这个多了个对象，这样所有值被合并到这个空对象上，保护了插件里面的默认值，可以保证传进来的值覆盖原来的默认值。<br><img src=\"/images/jquery/20170914154701.png\"></li>\n</ol>\n<p>所以，一般来说都会使用第二种方式传递参数。</p>\n<p>####面向对象插件开发<br>为什么要有面向对象的思维，因为如果不这样，你可能需要一个方法的时候就去定义一个function，当需要另外一个方法的时候，再去随便定义一个function，同样，需要一个变量的时候，毫无规则地定义一些散落在代码各处的变量。</p>\n<p>还是老问题，不方便维护，也不够清晰。当然，这些问题在代码规模较小时是体现不出来的。</p>\n<p>如果将需要的重要变量定义到对象的属性上，函数变成对象的方法，当我们需要的时候通过对象来获取，一来方便管理，二来不会影响外部命名空间，因为所有这些变量名还有方法名都是在对象内部。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">;(function($,window,document,undefined)&#123;\n    &#x2F;&#x2F; 变量声明\n    var pluginName &#x3D; &quot;changecolor&quot;,\n        defauts &#x3D; &#123;\n            &quot;colorArr&quot;:[&#39;#3793e2&#39;,&#39;#5ab55a&#39;,&#39;#cc3f65&#39;,&#39;#a526cb&#39;],\n            &quot;backgroundColor&quot;:&quot;#eee&quot;,\n            &quot;fontSize&quot;:&quot;14px&quot;\n        &#125;;\n    &#x2F;&#x2F; 构造函数\n    function changeColor(ele,options)&#123;\n        this.element &#x3D; ele;\n        this.settings &#x3D; $.extend(&#123;&#125;,defauts,options);\n        this.changecolor();\n        this.hover();\n    &#125;;\n    changeColor.prototype&#x3D; &#123;\n        changecolor: function()&#123;\n            var i &#x3D; Math.round(Math.random()*(this.settings.colorArr.length-1)),\n                arr &#x3D; this.settings.colorArr[i],\n                bg &#x3D; this.settings.backgroundColor,\n                fz &#x3D; this.settings.fontSize;\n            return $(this.element).each(function()&#123;\n                $(this).css(&#123;\n                    &quot;color&quot;:arr,\n                    &quot;backgroundColor&quot;:bg,\n                    &quot;fontSize&quot;:fz\n                &#125;);\n            &#125;);\n        &#125;,\n        hover: function()&#123;\n            $(this.element).each(function()&#123;\n               $(this).hover(function()&#123;\n                   $(this).css(&quot;color&quot;,&quot;#fff&quot;);\n               &#125;); \n            &#125;);\n        &#125;\n    &#125;;\n    $.fn[pluginName] &#x3D; function(options)&#123;\n        this.each(function()&#123;\n            if(!$.data(this,pluginName))&#123;\n                $.data(this,pluginName,new changeColor(this,options));\n            &#125;\n        &#125;);\n        return this;\n    &#125;\n&#125;)(jQuery,window,document);</code></pre>","text":" jQuery 的开发方式 通过$.extend()来扩展jQuery 通过$.fn向jQuery添加新方法 通过$.widget()应用jQuery UI的部件工厂方式创建 写在哪里写插件一般都是单独的一个文件出来，然后可重复的供他人调用。由于插件依赖的是jQuery，所以在写...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"JQuery","slug":"JQuery","count":1,"path":"api/categories/JQuery.json"}],"tags":[{"name":"JQuery","slug":"JQuery","count":1,"path":"api/tags/JQuery.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#jQuery-%E7%9A%84%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">jQuery 的开发方式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%9C%A8%E5%93%AA%E9%87%8C\"><span class=\"toc-text\">写在哪里</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#extend\"><span class=\"toc-text\">$.extend()</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#fn\"><span class=\"toc-text\">$.fn</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">基本格式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90\"><span class=\"toc-text\">简单的例子</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%99%E9%93%BE%E6%8E%A5%E4%B8%8A%E8%89%B2\"><span class=\"toc-text\">给链接上色</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#each\"><span class=\"toc-text\">each()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%94%AF%E6%8C%81%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">支持链式调用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">接收参数</span></a></li></ol></li></ol></li></ol>","author":{"name":"Lim Forson","slug":"lim-forson","avatar":"/images/avatar/avatar.png","link":"/","description":"Stay hungry, Stay foolish.","socials":{"github":"https://github.com/linfushan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2151406113","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"H5中简单的PDF文件预览","uid":"b2cc4378449d336ad426ce0756b96b31","slug":"plugins/plugin_001","date":"2023-05-24T02:54:44.539Z","updated":"2023-06-18T13:20:45.966Z","comments":true,"path":"api/articles/plugins/plugin_001.json","keywords":null,"cover":"../../images/plugins/pdf5.jpg","text":" 在web页面中预览pdf文件的方式有多种，有的是直接打开，有的是借助不同的封装插件进行预览，这里介绍一个极其简单的预览插件。 使用到的插件 pdfh5 axios 安装npm i pdfh5 --save 导入插件import Pdfh5 from &#39;pdfh5&#39...","link":"","photos":[],"count_time":{"symbolsCount":518,"symbolsTime":"1 mins."},"categories":[{"name":"Plugins","slug":"Plugins","count":1,"path":"api/categories/Plugins.json"}],"tags":[{"name":"pdfh5","slug":"pdfh5","count":1,"path":"api/tags/pdfh5.json"}],"author":{"name":"Lim Forson","slug":"lim-forson","avatar":"/images/avatar/avatar.png","link":"/","description":"Stay hungry, Stay foolish.","socials":{"github":"https://github.com/linfushan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2151406113","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"apply()和call()的使用","uid":"1ff54552393e0b2b43253a5d68ca54e8","slug":"javascript/js_001","date":"2023-05-23T02:29:30.251Z","updated":"2023-05-24T03:00:49.758Z","comments":true,"path":"api/articles/javascript/js_001.json","keywords":null,"cover":null,"text":"apply()和call()作用call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。 方法定义call 和 apply二者的作用完全一样，只是接受参数的方式不太一样。 方法&#x2F;*ap...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"Javascript","slug":"Javascript","count":3,"path":"api/categories/Javascript.json"}],"tags":[{"name":"Javascript","slug":"Javascript","count":3,"path":"api/tags/Javascript.json"}],"author":{"name":"Lim Forson","slug":"lim-forson","avatar":"/images/avatar/avatar.png","link":"/","description":"Stay hungry, Stay foolish.","socials":{"github":"https://github.com/linfushan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2151406113","zhihu":"","csdn":"","juejin":"","customs":{}}}}}