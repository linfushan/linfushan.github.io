{"title":"async/await、promise和setTimeout的执行顺序","uid":"e6867a211c96168f16cd6a99706fc29e","slug":"javascript/js_003","date":"2023-06-03T13:08:08.502Z","updated":"2023-06-18T13:17:48.062Z","comments":true,"path":"api/articles/javascript/js_003.json","keywords":null,"cover":"../../images/javascript/js_003_01.png","content":"<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">你需要提前知道的知识点</p>\n<p><pre><code>1. 什么是进程和线程？\n2. 任务如何调度？\n</code></pre>\n</p>\n</div>\n<h1 id=\"何为进程？\"><a href=\"#何为进程？\" class=\"headerlink\" title=\"何为进程？\"></a>何为进程？</h1><p>程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程，<strong>进程是内存分配的最小单位</strong>。</p>\n<p>每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。</p>\n<h1 id=\"何为线程？\"><a href=\"#何为线程？\" class=\"headerlink\" title=\"何为线程？\"></a>何为线程？</h1><p>有了进程后，就可以运行程序的代码了。</p>\n<p>运行代码的「人」称之为「线程」，<strong>线程是执行的最小单位</strong>。</p>\n<p>一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。</p>\n<p>如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。</p>\n<h1 id=\"浏览器中的进程和线程\"><a href=\"#浏览器中的进程和线程\" class=\"headerlink\" title=\"浏览器中的进程和线程\"></a>浏览器中的进程和线程</h1><p>为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p>\n<p>其中主要的进程有：</p>\n<ol>\n<li>浏览器进程<br> 主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</li>\n<li>网络进程<br> 负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。</li>\n<li><strong>渲染进程</strong><br> 渲染进程启动后，会开启一个<strong>渲染主线程</strong>，主线程负责执行 HTML、CSS、JS 代码。<br> 默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。</li>\n</ol>\n<h1 id=\"渲染主线程是如何工作的？\"><a href=\"#渲染主线程是如何工作的？\" class=\"headerlink\" title=\"渲染主线程是如何工作的？\"></a>渲染主线程是如何工作的？</h1><p>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：</p>\n<ul>\n<li>解析 HTML</li>\n<li>解析 CSS</li>\n<li>计算样式</li>\n<li>布局</li>\n<li>处理图层</li>\n<li>每秒把页面画 60 次</li>\n<li>执行全局 JS 代码</li>\n<li>执行事件处理函数</li>\n<li>执行计时器的回调函数</li>\n<li>……</li>\n</ul>\n<p>要处理这么多的任务，主线程遇到了一个前所未有的难题：<strong>如何调度任务？</strong></p>\n<p>渲染主线程想出了一个绝妙的主意来处理这个问题：<strong>排队</strong></p>\n<p><img src=\"/images/javascript/js_003_01.png\" alt=\"任务排队\"></p>\n<ol>\n<li>在最开始的时候，渲染主线程会进入一个<strong>无限循环</strong>(<code>for(;;)</code>)</li>\n<li>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。</li>\n<li>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务。</li>\n</ol>\n<p>这样一来，就可以让每个任务有条不紊的、持续的进行下去了。</p>\n<p><strong>整个过程，被称之为事件循环（chrome源码里面称之为消息循环）</strong></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">阐述一下 JS 的事件循环</p>\n<p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。<br>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。<br>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。<br>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p>\n\n</div>\n<p>代码在执行过程中，会遇到一些无法立即处理的任务，比如：</p>\n<ul>\n<li>计时完成后需要执行的任务 —— <code>setTimeout</code>、<code>setInterval</code></li>\n<li>网络通信完成后需要执行的任务 – <code>XHR</code>、<code>Fetch</code></li>\n<li>用户操作后需要执行的任务 – <code>addEventListener</code></li>\n</ul>\n<p>如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」</p>\n<p><strong>渲染主线程承担着极其重要的工作，无论如何都不能阻塞！</strong></p>\n<p>因此，浏览器选择<strong>异步</strong>来解决这个问题</p>\n<p><img src=\"/images/javascript/js_003_02.png\" alt=\"异步\"></p>\n<p>使用异步的方式，<strong>渲染主线程永不阻塞</strong></p>\n<h1 id=\"何为异步\"><a href=\"#何为异步\" class=\"headerlink\" title=\"何为异步\"></a>何为异步</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p>\n<p>而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。</p>\n<p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p>\n<p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p>\n<p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p></blockquote>\n<h1 id=\"JS为何会阻碍渲染？\"><a href=\"#JS为何会阻碍渲染？\" class=\"headerlink\" title=\"JS为何会阻碍渲染？\"></a>JS为何会阻碍渲染？</h1><p>阻塞渲染例子：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;h1&gt;Hello Javascript!&lt;&#x2F;h1&gt;\n&lt;button&gt;change&lt;&#x2F;button&gt;\n&lt;script&gt;\n  var h1 &#x3D; document.querySelector(&#39;h1&#39;);\n  var btn &#x3D; document.querySelector(&#39;button&#39;);\n\n  &#x2F;&#x2F; 死循环指定的时间\n  function delay(duration) &#123;\n    var start &#x3D; Date.now();\n    while (Date.now() - start &lt; duration) &#123;&#125;\n  &#125;\n\n  btn.onclick &#x3D; function () &#123;\n    h1.textContent &#x3D; &#39;你好，我晚到了3秒！&#39;;\n    delay(3000);\n  &#125;;\n&lt;&#x2F;script&gt;</code></pre>\n<p>点击按钮后，<code>h1</code>被赋值后，并没有马上渲染到标签内，而是阻塞3秒后才渲染上去。</p>\n<h1 id=\"任务有优先级吗？\"><a href=\"#任务有优先级吗？\" class=\"headerlink\" title=\"任务有优先级吗？\"></a>任务有优先级吗？</h1><p>任务没有优先级，在消息队列中先进先出</p>\n<p>但<strong>消息队列是有优先级的</strong></p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">根据 W3C 的最新解释</p>\n<p><ul>\n<li>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。</li>\n<li>在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</li>\n<li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行  </li>\n<li>随着浏览器的复杂度急剧提升，<a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint\" target=\"_blank\">W3C</a> 不再使用宏队列的说法</li>\n</ul>\n</p>\n</div>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><p>在目前 chrome 的实现中，至少包含了下面的队列：</p>\n<ul>\n<li><strong>延时队列</strong>：用于存放计时器到达后的回调任务，优先级「中」</li>\n<li><strong>交互队列</strong>：用于存放用户操作后产生的事件处理任务，优先级「高」</li>\n<li><strong>微队列</strong>：用户存放需要最快执行的任务，优先级「最高」</li>\n</ul>\n<p><img src=\"/images/javascript/js_003_03.png\"></p>\n<h1 id=\"实例演示\"><a href=\"#实例演示\" class=\"headerlink\" title=\"实例演示\"></a>实例演示</h1><p><strong>例一</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">setTimeout(function () &#123;\n  console.log(1);\n&#125;, 0);\n\nfunction delay(duration) &#123;\n  var start &#x3D; Date.now();\n  while (Date.now() - start &lt; duration) &#123;&#125;\n&#125;\ndelay(3000);\nconsole.log(2);</code></pre>\n<ol>\n<li><code>setTimeout</code>属于延时队列，这里立即执行，放到延时队列里面；</li>\n<li><code>delay()</code>进入死循环三秒；</li>\n<li>三秒过后运行<code>console.log(2)</code>,首先输出2；</li>\n<li>执行完毕，再将延时队列放到主线程运行，最后输出1。</li>\n</ol>\n<p>结果：2 1</p>\n<p><strong>例二</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function a() &#123;\n  console.log(1);\n  Promise.resolve().then(function () &#123;\n    console.log(2);\n  &#125;);\n&#125;\nsetTimeout(function () &#123;\n  console.log(3);\n&#125;, 0);\n\nPromise.resolve().then(a);\nconsole.log(4);</code></pre>\n\n<ol>\n<li><code>setTimeout</code>属于延时队列，这里立即执行，放到延时队列里面，记为fn3；</li>\n<li><code>Promise.resolve().then(a)</code>放到微队列，记为fn1；</li>\n<li>继续运行，直接输出4；</li>\n<li>调用微队列的fn1任务：执行a方法，直接输出1，结束fn1任务，然后把<code>Promise.resolve().then(function () &#123;console.log(2);&#125;)</code>放到微队列，记为fn2；</li>\n<li>执行fn2任务，输出2，结束fn2;</li>\n<li>执行延时任务fn3，输出3.</li>\n</ol>\n<p>结果：4 1 2 3</p>\n<p><strong>例三</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">async function async1() &#123;\n\tconsole.log(&#39;async1 start&#39;);\n\tawait async2();\n\tconsole.log(&#39;asnyc1 end&#39;);\n&#125;\nasync function async2() &#123;\n\tconsole.log(&#39;async2&#39;);\n&#125;\nconsole.log(&#39;script start&#39;);\nsetTimeout(() &#x3D;&gt; &#123;\n\tconsole.log(&#39;setTimeOut&#39;);\n&#125;, 0);\nasync1();\nnew Promise(function (reslove) &#123;\n\tconsole.log(&#39;promise1&#39;);\n\treslove();\n&#125;).then(function () &#123;\n\tconsole.log(&#39;promise2&#39;);\n&#125;)\nconsole.log(&#39;script end&#39;);</code></pre>\n\n<ol>\n<li>整个代码片段（script）作为一个宏任务执行<code>console.log(&#39;script start&#39;)</code>，输出<code>script start</code>；</li>\n<li>执行<code>setTimeout</code>，是一个异步动作，放入宏任务异步队列中；</li>\n<li>执行<code>async1()</code>，输出<code>async1 start</code>，继续向下执行；</li>\n<li>执行<code>async2()</code>，输出<code>async2</code>，并返回了一个<code>promise</code>对象，<code>await</code>让出了线程，把返回的<code>promise</code>加入了微任务异步队列，所以<code>async1()</code>下面的代码也要等待上面完成后继续执行;</li>\n<li>执行 <code>new Promise</code>，输出<code>promise1</code>，然后将<code>resolve()</code>放入微任务异步队列；</li>\n<li>执行<code>console.log(&#39;script end&#39;)</code>，输出<code>script end</code>；</li>\n<li>到此同步的代码就都执行完成了，然后去微任务异步队列里去获取任务</li>\n<li>接下来执行<code>resolve</code>（<code>async2</code>返回的<code>promise</code>返回的），输出了<code>async1 end</code>；</li>\n<li>然后执行<code>resolve</code>（<code>new Promise</code>的），输出了<code>promise2</code>；</li>\n<li>最后执行<code>setTimeout</code>，输出了<code>settimeout</code>。</li>\n</ol>\n<p>最后一个例子看起来会比较的复杂，需要理解<code>promise</code>和<code>async/await</code>。</p>\n<p>首先，<code>new Promise</code>是同步的任务，会被放到主进程中去立即执行。而<code>.then()</code>函数是异步任务会放到异步队列中去，那什么时候放到异步队列中去呢？当你的<code>promise</code>状态结束的时候，就会立即放进异步队列中去了。</p>\n<p>带<code>async</code>关键字的函数会返回一个<code>promise</code>对象，如果里面没有<code>await</code>，执行起来等同于普通函数。</p>\n<p><code>await</code>如同他的语意，就是在等待，等待右侧的表达式完成。此时的<code>await</code>会让出线程，阻塞<code>async</code>内后续的代码，先去执行<code>async</code>外的代码。等外面的同步代码执行完毕，才会执行里面的后续代码。</p>\n","feature":true,"text":" 你需要提前知道的知识点 1. 什么是进程和线程？ 2. 任务如何调度？ 何为进程？程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程，进程是内存分配的最小单位。 每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。 何为线程？有了进程后，就...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"Javascript","slug":"Javascript","count":3,"path":"api/categories/Javascript.json"}],"tags":[{"name":"Javascript","slug":"Javascript","count":3,"path":"api/tags/Javascript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%95%E4%B8%BA%E8%BF%9B%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">何为进程？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%95%E4%B8%BA%E7%BA%BF%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">何为线程？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">浏览器中的进程和线程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B8%B2%E6%9F%93%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">渲染主线程是如何工作的？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%95%E4%B8%BA%E5%BC%82%E6%AD%A5\"><span class=\"toc-text\">何为异步</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JS%E4%B8%BA%E4%BD%95%E4%BC%9A%E9%98%BB%E7%A2%8D%E6%B8%B2%E6%9F%93%EF%BC%9F\"><span class=\"toc-text\">JS为何会阻碍渲染？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E6%9C%89%E4%BC%98%E5%85%88%E7%BA%A7%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">任务有优先级吗？</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97\"><span class=\"toc-text\">队列</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">实例演示</span></a></li></ol>","author":{"name":"Lim Forson","slug":"lim-forson","avatar":"/images/avatar/avatar.png","link":"/","description":"Stay hungry, Stay foolish.","socials":{"github":"https://github.com/linfushan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2151406113","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"n 管理 node 版本","uid":"8daf5819f3cca3bfa30bc434c8ba2be7","slug":"tools/n","date":"2023-06-18T04:58:39.489Z","updated":"2023-06-18T12:56:45.403Z","comments":true,"path":"api/articles/tools/n.json","keywords":null,"cover":"../../images/tools/n.png","text":"在前端开发的过程中，由于项目的不同和公司设定项目方案的不同，常常会用到不同的 Node 版本，且各个版本的相容程度很差，如果没有版本的管理就需要卸载安装不同版本的Node，这就回很麻烦，所以 Node的版本很管理很重要。 这里给大家介绍一个好用的 Node 版本管理套件 n 支持...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"Node","slug":"Node","count":2,"path":"api/categories/Node.json"}],"tags":[{"name":"node","slug":"node","count":2,"path":"api/tags/node.json"},{"name":"n","slug":"n","count":1,"path":"api/tags/n.json"}],"author":{"name":"Lim Forson","slug":"lim-forson","avatar":"/images/avatar/avatar.png","link":"/","description":"Stay hungry, Stay foolish.","socials":{"github":"https://github.com/linfushan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2151406113","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"call()、apply()和bind()的区别和用法","uid":"113d3c4a95b3b3fd262131044de9db93","slug":"javascript/js_002","date":"2023-06-02T15:58:21.739Z","updated":"2023-06-18T12:55:45.251Z","comments":true,"path":"api/articles/javascript/js_002.json","keywords":null,"cover":"../../images/javascript/call-apply-bind.png","text":" 带着问题去理解 1. 这三个方法的作用是什么？ 2. 如何使用，共同点和区别在哪里？ 3. 为什么要使用这些方法？ 4. 方法的使用场景。 前言经常会看到文章有写关于 call() 和 apply() 的一些区别和使用，在学习 react 的时候也遇到用 bind() 这个方法...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"Javascript","slug":"Javascript","count":3,"path":"api/categories/Javascript.json"}],"tags":[{"name":"Javascript","slug":"Javascript","count":3,"path":"api/tags/Javascript.json"}],"author":{"name":"Lim Forson","slug":"lim-forson","avatar":"/images/avatar/avatar.png","link":"/","description":"Stay hungry, Stay foolish.","socials":{"github":"https://github.com/linfushan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2151406113","zhihu":"","csdn":"","juejin":"","customs":{}}}}}