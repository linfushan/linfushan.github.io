{"title":"call()、apply()和bind()的区别和用法","uid":"113d3c4a95b3b3fd262131044de9db93","slug":"javascript/js_002","date":"2023-06-02T15:58:21.739Z","updated":"2023-06-18T12:55:45.251Z","comments":true,"path":"api/articles/javascript/js_002.json","keywords":null,"cover":"../../images/javascript/call-apply-bind.png","content":"<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">带着问题去理解</p>\n<p><pre><code>1. 这三个方法的作用是什么？\n2. 如何使用，共同点和区别在哪里？\n3. 为什么要使用这些方法？\n4. 方法的使用场景。\n</code></pre>\n</p>\n</div>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>经常会看到文章有写关于 <code>call()</code> 和 <code>apply()</code> 的一些区别和使用，在学习 <strong>react</strong> 的时候也遇到用 <code>bind()</code> 这个方法来改变 <code>this</code> 的指向，所以这次就直接三者一起整合起来做一个总结。</p>\n<p>突然有这个想法，主要是因为这次面试的时候，被面试官问到这三个方法的区别，所以借此机会总结记录一下。</p>\n<h1 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h1><p>所谓的作用就是其存在的意义，那三个方法存在的一样是什么？</p>\n<p>意义就是：<strong>改变函数执行时的上下文，也就是改变函数运行时的this指向，或者是说重新定义this这个对象。</strong></p>\n<p>这也是三个方法的主要<strong>相同点</strong>。</p>\n<h1 id=\"为何改变执行上下文\"><a href=\"#为何改变执行上下文\" class=\"headerlink\" title=\"为何改变执行上下文\"></a>为何改变执行上下文</h1><p>举一个生活上的例子：最近网上很火的公共厨房一样，那些病人家属想给自己人煮点好吃的，但是出门在外这些都是临时的，总不能煮个饭还去买各种锅碗瓢盆，再去搭个灶台吧。所以就借用公共厨房的工具来煮菜，这样就达到的目的，又节省了开支。</p>\n<p>三个方法的用途也是一样，A对象有个方法，B对象因为某种原因也需要同样的方法，为了不造成代码的冗佘，B对象这边直接借用A的方法，这样既完成了需求，又减少了内存的占用。</p>\n<h1 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h1><p><code>call()</code>、<code>apply()</code>和<code>bind()</code>这三个函数的调用对象必须是一个<code>Function</code></p>\n<p>第一个参数thisArg都是 <code>this</code> 的指向对象。</p>\n<div class=\"custom-quote warning\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 15.99V16.01\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">thisArg传值注意的点</p>\n<p><pre><code>1. 不传或者传null，undefined， 函数中的 this 指向 window 对象\n2. 值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象，如 String、Number、Boolean\n3. 传递另一个函数的函数名，函数中的this指向这个函数的引用，并不一定是该函数执行时真正的this值\n4. 传递一个对象，函数中的this指向这个对象\n</code></pre>\n</p>\n</div>\n<p>第二个参数就有所区别了：<br><code>call()</code>和<code>bind()</code>之后的参数全部用逗号分隔，直接放到后面去，而<code>apply()</code>则是传递一个数组。<br><code>bind()</code>返回是个函数，且参数可在调用的时候直接传入，其他的都和<code>call()</code>一样。</p>\n<p>三者的参数不限定是 string 类型，允许是各种类型，包括函数 、 object 等等</p>\n<h2 id=\"Function-prototype-call\"><a href=\"#Function-prototype-call\" class=\"headerlink\" title=\"Function.prototype.call()\"></a>Function.prototype.call()</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">call(thisArg)\ncall(thisArg, arg1)\ncall(thisArg, arg1, &#x2F;* …, *&#x2F; argN)</code></pre>\n\n<h2 id=\"Function-prototype-apply\"><a href=\"#Function-prototype-apply\" class=\"headerlink\" title=\"Function.prototype.apply()\"></a>Function.prototype.apply()</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">apply(thisArg)\napply(thisArg, argsArray)</code></pre>\n\n<h2 id=\"Function-prototype-bind\"><a href=\"#Function-prototype-bind\" class=\"headerlink\" title=\"Function.prototype.bind()\"></a>Function.prototype.bind()</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">bind(thisArg)\nbind(thisArg, arg1)\nbind(thisArg, arg1, &#x2F;* …, *&#x2F; argN)</code></pre>\n\n<h1 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h1><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let obj &#x3D; &#123;\n\tname: &#39;张三&#39;,\n\tage: 53,\n\tmyFunction: function(sex, from) &#123;\n\t\tconsole.log(&#39;我叫&#39; + this.name + &#39;，&#39; + sex + &#39;，今年&#39; + this.age + &#39;岁，来自&#39; + from)\n\t&#125;\n&#125;\nlet thisArg &#x3D; &#123;\n\tname: &#39;李四&#39;,\n\tage: 13\n&#125;\nobj.myFunction.call(thisArg, &#39;男&#39;, &#39;东山&#39;)\nobj.myFunction.apply(thisArg, [&#39;男&#39;, &#39;东山&#39;])\nobj.myFunction.bind(thisArg, &#39;男&#39;)(&#39;东山&#39;)\n&#x2F;&#x2F; 或者也可以这样写\nconst func &#x3D; obj.myFunction.bind(thisArg, &#39;男&#39;)\nfunc(&#39;东山&#39;)\n</code></pre>\n<p>运行结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">我叫李四，男，今年13岁，来自东山\n我叫李四，男，今年13岁，来自东山\n我叫李四，男，今年13岁，来自东山</code></pre>\n\n<p><code>bind()</code>返回一个函数，里面的传值可在调用的在动态传值，但是所有的传值个数必须和函数的传参保持一致。</p>\n<h1 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h1><h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function superClass() &#123;\n\tthis.greet &#x3D; &#39;Hello&#39;\n\tthis.print &#x3D; function(name) &#123;\n\t\tconsole.log(this.greet + &#39; &#39; + name)\n\t&#125;\n&#125;\n\nfunction subClass() &#123;\n\t&#x2F;&#x2F; 方法一\n\t&#x2F;&#x2F; superClass.call(this)\n\t&#x2F;&#x2F; 方法二\n\tsuperClass.apply(this)\n\tthis.print(&#39;Javascript&#39;)\n&#125;\nsubClass()\n&#x2F;&#x2F; Hello Javascript</code></pre>\n<p><code>subClass</code> 通过 <code>call</code> 方法，继承了 <code>superClass</code> 的 <code>print</code> 方法和 <code>name</code> 变量。此外，<code>subClass</code> 还可以扩展自己的其他方法。</p>\n<h2 id=\"原型扩展\"><a href=\"#原型扩展\" class=\"headerlink\" title=\"原型扩展\"></a>原型扩展</h2><p>在原型函数上扩展和自定义方法，从而不污染原生函数。例如：我们在 <code>Array</code> 上扩展一个 <code>forEach</code></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function test() &#123;\n\t&#x2F;&#x2F; 检测arguments是否为Array的实例\n\tconsole.log(\n\t\targuments instanceof Array, &#x2F;&#x2F;false\n\t\tArray.isArray(arguments) &#x2F;&#x2F;false\n\t);\n\t&#x2F;&#x2F; 判断arguments是否有forEach方法\n\tconsole.log(arguments.forEach); &#x2F;&#x2F; undefined\n\t&#x2F;&#x2F; 将数组中的forEach应用到arguments上\n\tArray.prototype.forEach.call(arguments, function(item) &#123;\n\t\tconsole.log(item); &#x2F;&#x2F; 1 2 3 4\n\t&#125;);\n&#125;\ntest(1, 2, 3, 4);</code></pre>\n\n<h2 id=\"用来判断类型\"><a href=\"#用来判断类型\" class=\"headerlink\" title=\"用来判断类型\"></a>用来判断类型</h2><p>因为 <code>Object.prototype.toString()</code> 方法会返回对象的类型字符串，输出 <code>&quot;[object Object]&quot;</code> 其中第二个 <code>Object</code> 是传入参数的构造函数。所以使用 <code>call</code> 就可以指定任意的值和结合 <code>toString</code> 将组成的构造函数类型返回来判断类型。同样道理换成 <code>apply/bind</code> 同样也可以判断</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Object.prototype.toString.call(&#39;str&#39;)   &#x2F;&#x2F; &quot;[object String]&quot;\nObject.prototype.toString.call(123)   &#x2F;&#x2F; &quot;[object Number]&quot;\nObject.prototype.toString.call(&#123;&#125;)      &#x2F;&#x2F;  &quot;[object Object]&quot;\nObject.prototype.toString.call([])      &#x2F;&#x2F;  &quot;[object Array]&quot;\n\nObject.prototype.toString.apply(&#123;&#125;)      &#x2F;&#x2F;  &quot;[object Object]&quot;\nObject.prototype.toString.apply([])      &#x2F;&#x2F;  &quot;[object Array]&quot;\n\nvar f &#x3D; Object.prototype.toString.bind(&#123;&#125;)\nf()     &#x2F;&#x2F;  &quot;[object Object]&quot;\nvar fn &#x3D; Object.prototype.toString.bind([])\nfn()   &#x2F;&#x2F;  &quot;[object Array]&quot;</code></pre>\n\n<h2 id=\"扩充函数赖以运行的作用域\"><a href=\"#扩充函数赖以运行的作用域\" class=\"headerlink\" title=\"扩充函数赖以运行的作用域\"></a>扩充函数赖以运行的作用域</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">window.color &#x3D; &quot;red&quot;;  \nvar o &#x3D; &#123;color: &quot;blue&quot;&#125;;  \nfunction sayColor() &#123;  \n       alert(this.color);  \n&#125;  \nsayColor( ); &#x2F;&#x2F;red  \nsayColor.call(this);&#x2F;&#x2F;red  \nsayColor.call(window);&#x2F;&#x2F;red  \nsayColor.call(o);&#x2F;&#x2F;blue   将sayColor的this指向o</code></pre>\n<p>使用<code>call()</code>（或<code>apply()</code>）来扩充作用域最大的好处，就是对象不需要与方法有任何耦合关系。</p>\n<h2 id=\"妙用\"><a href=\"#妙用\" class=\"headerlink\" title=\"妙用\"></a>妙用</h2><p><code>Math.max</code>或<code>Math.min</code>用<code>apply</code>来获取数组中最大的值。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let max &#x3D; Math.max.apply(null, arrary)</code></pre>\n<p>这时候你可能会问，为什么要这么复杂呢？直接用扩展运算符不就好了，就像这样：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let max &#x3D; Math.max(...arrary)</code></pre>\n<p>但是这里讲的是<code>javacript</code>，而扩展运算符则是<code>es6</code>的。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>这些大概就是三个方法的基本用法，最主要的还是三者在实战中的使用，若还有更好的实战使用，欢迎留言告知！</p>\n","text":" 带着问题去理解 1. 这三个方法的作用是什么？ 2. 如何使用，共同点和区别在哪里？ 3. 为什么要使用这些方法？ 4. 方法的使用场景。 前言经常会看到文章有写关于 call() 和 apply() 的一些区别和使用，在学习 react 的时候也遇到用 bind() 这个方法...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"Javascript","slug":"Javascript","count":3,"path":"api/categories/Javascript.json"}],"tags":[{"name":"Javascript","slug":"Javascript","count":3,"path":"api/tags/Javascript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">作用</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BD%95%E6%94%B9%E5%8F%98%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">为何改变执行上下文</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Function-prototype-call\"><span class=\"toc-text\">Function.prototype.call()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Function-prototype-apply\"><span class=\"toc-text\">Function.prototype.apply()</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Function-prototype-bind\"><span class=\"toc-text\">Function.prototype.bind()</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%BE%E4%BE%8B\"><span class=\"toc-text\">举例</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">使用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">继承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">原型扩展</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%9D%A5%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">用来判断类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%85%85%E5%87%BD%E6%95%B0%E8%B5%96%E4%BB%A5%E8%BF%90%E8%A1%8C%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">扩充函数赖以运行的作用域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%99%E7%94%A8\"><span class=\"toc-text\">妙用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%90%8E\"><span class=\"toc-text\">最后</span></a></li></ol>","author":{"name":"Lim Forson","slug":"lim-forson","avatar":"/images/avatar/avatar.png","link":"/","description":"Stay hungry, Stay foolish.","socials":{"github":"https://github.com/linfushan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2151406113","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"async/await、promise和setTimeout的执行顺序","uid":"e6867a211c96168f16cd6a99706fc29e","slug":"javascript/js_003","date":"2023-06-03T13:08:08.502Z","updated":"2023-06-18T13:17:48.062Z","comments":true,"path":"api/articles/javascript/js_003.json","keywords":null,"cover":"../../images/javascript/js_003_01.png","text":" 你需要提前知道的知识点 1. 什么是进程和线程？ 2. 任务如何调度？ 何为进程？程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程，进程是内存分配的最小单位。 每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。 何为线程？有了进程后，就...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"Javascript","slug":"Javascript","count":3,"path":"api/categories/Javascript.json"}],"tags":[{"name":"Javascript","slug":"Javascript","count":3,"path":"api/tags/Javascript.json"}],"author":{"name":"Lim Forson","slug":"lim-forson","avatar":"/images/avatar/avatar.png","link":"/","description":"Stay hungry, Stay foolish.","socials":{"github":"https://github.com/linfushan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2151406113","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"CSS hack","uid":"58de8212a988128478edd77479cf970b","slug":"css/css_002","date":"2023-05-26T06:48:44.939Z","updated":"2023-06-18T13:11:03.708Z","comments":true,"path":"api/articles/css/css_002.json","keywords":null,"cover":"../../images/css/css_hack.jpg","text":"css hack兼容范围：IE:6.0+，FireFox:2.0+，Opera 10.0+，Sarari 3.0+，Chrome 各浏览器hack兼容一览表 标记 IE6 IE7 IE8 FF Opera Sarari [*+&gt;&lt;] ✔ ✔ ✘ ✘ ✘ ✘ _ ✔ ✘...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"CSS","slug":"CSS","count":2,"path":"api/categories/CSS.json"}],"tags":[{"name":"CSS","slug":"CSS","count":2,"path":"api/tags/CSS.json"},{"name":"CSS HACK","slug":"CSS-HACK","count":1,"path":"api/tags/CSS-HACK.json"}],"author":{"name":"Lim Forson","slug":"lim-forson","avatar":"/images/avatar/avatar.png","link":"/","description":"Stay hungry, Stay foolish.","socials":{"github":"https://github.com/linfushan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/2151406113","zhihu":"","csdn":"","juejin":"","customs":{}}}}}