[{"id":"9f8dfcc48086625af0ae4278580b5a7d","title":"nrm 管理 npm 源","content":"nrm (npm registry manager)是 npm 的镜像源管理工具，有时候国外资源太慢或访问不了，使用这个就可以快速地在 npm 源间切换。\n\n\n\n\n\n\n\n\n\nnpm 包主要是根据 node 安装的版本来确定使用的版本，而 node 版本也会因为项目的使用而有所限定，所以也会有一个管理工具来管理相应的包，可参考n管理node版本\n全局安装npm i -g nrm\n\n查看是否安装成功nrm --version\n\n查看可用的npm源npm ls\n\n结果：\nnpm ---------- https:&#x2F;&#x2F;registry.npmjs.org&#x2F;\nyarn --------- https:&#x2F;&#x2F;registry.yarnpkg.com&#x2F;\ntencent ------ https:&#x2F;&#x2F;mirrors.cloud.tencent.com&#x2F;npm&#x2F;\ncnpm --------- https:&#x2F;&#x2F;r.cnpmjs.org&#x2F;\ntaobao ------- https:&#x2F;&#x2F;registry.npmmirror.com&#x2F;\nnpmMirror ---- https:&#x2F;&#x2F;skimdb.npmjs.com&#x2F;registry&#x2F;\n\n切换使用源nrm use taobao\n查看 npm 源地址npm config list 或 npm config get registry，这个也可以查看当前源是否切换成功。\n% npm config list\n; cli configs\nmetrics-registry &#x3D; &quot;https:&#x2F;&#x2F;registry.npmmirror.com&#x2F;&quot;\nscope &#x3D; &quot;&quot;\nuser-agent &#x3D; &quot;npm&#x2F;6.14.13 node&#x2F;v14.17.0 darwin x64&quot;\n\n; userconfig &#x2F;Users&#x2F;linfushan&#x2F;.npmrc\n@bit:registry &#x3D; &quot;https:&#x2F;&#x2F;node.bit.dev&quot;\nhome &#x3D; &quot;https:&#x2F;&#x2F;npm.taobao.org&quot;\nregistry &#x3D; &quot;https:&#x2F;&#x2F;registry.npmmirror.com&#x2F;&quot;\nsass_binary_site &#x3D; &quot;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node-sass&quot;\n\n; node bin location &#x3D; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node\n; cwd &#x3D; &#x2F;Users&#x2F;hexo&#x2F;linfushan\n; HOME &#x3D; &#x2F;Users&#x2F;linfushan\n; &quot;npm config ls -l&quot; to show all defaults.\n\n% npm config get registry\nhttps:&#x2F;&#x2F;registry.npmmirror.com&#x2F;\n\n添加使用源如果没有想要的 npm源，那么可以使用一下的方法自行添加。\nnrm add [registry] [url]\nregistry：源名称（自己定义）url：源地址\nnrm add public http:&#x2F;&#x2F;192.168.1.2:8888&#x2F;npm-public\n\n\n\n\n\n\n\n\n\n\n以下 [registry] 没有特殊说明，即都为 源名称\n测试使用源的速度nrm test [registry]\n% nrm test taobao\n\n* taobao --- 476ms\n\n删除源nrm del [registry]\n修改源地址nrm set registry [url]\nnpm set registry https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;\n\n使用特定源安装包npm i logo --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org\n\n查看源的主页nrm home [registry]，使用该命令会跳到 .npmrc 文件中配置的 home 的主页，在默认浏览器打开。\n","slug":"tools/nrm","date":"2023-06-18T05:56:34.104Z","categories_index":"Node","tags_index":"node,nrm","author_index":"Lim Forson"},{"id":"8daf5819f3cca3bfa30bc434c8ba2be7","title":"n 管理 node 版本","content":"在前端开发的过程中，由于项目的不同和公司设定项目方案的不同，常常会用到不同的 Node 版本，且各个版本的相容程度很差，如果没有版本的管理就需要卸载安装不同版本的Node，这就回很麻烦，所以 Node的版本很管理很重要。\n这里给大家介绍一个好用的 Node 版本管理套件 n\n\n\n\n\n\n\n\n支持环境\nn does not work in native shells on Microsoft Windows (like PowerShell), or Git for Windows BASH, or with the Cygwin DLL.译：n 不适用于 Microsoft Windows 上的本机 shell（如 PowerShell）、Windows BASH 的 Git 或 Cygwin DLL。\n\n\n\n\n\n\n\n\n\n\n还有一个管理器是nvm，但是本人觉的n使用起来会比较方便。\n安装全局安装 n 管理包\nnpm i -g n\n\n查看是否安装成功\nn --version\n7.3.1\n\n安装node版本安装指定版本n &lt;node version&gt;[ &lt;node version&gt;]\n安装 14.15.0 版本，安装完后会自动切换到当前版本。如果该版本已经安装，则会切换到当前版本。\nsudo n 14.15.0\n查看是否安装成功\nnode --version\n14.15.0\n\n安装最新官方版本n latest\n\n安装最新稳定官方版本n stable\n\n安装最新的LTS官方版本n lts\n\n\n\n\n\n\n\n\nMac 操作提示\n当安装的时候提示：Error: sudo required这是因为管理员权限才能操作，因此需要使用 sudo 。\n\nMac系统，所有已经安装的node版本存放路径：/usr/local/n/versions/node\n安装的目录查看和切换已安装的版本查看已安装的版本，和当前使用的版本。可用上下箭头选择 Node 版本，Enter 确定切换版本。\nn\n    node&#x2F;14.7.0\n  ο node&#x2F;14.15.0\n    node&#x2F;18.16.0\n\nUse up&#x2F;down arrow keys to select a version, return key to install, d to delete, q to quit\n删除node版本删除指定版本n rm &lt;node version&gt;[ &lt;node version&gt;]，这里的rm可简写成-。\nn rm 14.15.0 18.16.0\n或\nn - 14.15.0 18.16.0\n\n删除当前版本外的其他版本n prune\n\n用指定的版本来指定脚本n use 14.15.0 index.js\n\n关于n的使用命令install: i # 安装版本，可省略\nlatest: current # 安装当前最新版本\nls: list # 查看所有安装的版本\nlsr: ls-remote # 获取远程版本\nlts: stable # 安装官网稳定版本\nrm: - # 删除版本\nrun: use, as # 以指定的版本来执行脚本\nwhich: bin # n的bin目录\n\n","slug":"tools/n","date":"2023-06-18T04:58:39.489Z","categories_index":"Node","tags_index":"node,n","author_index":"Lim Forson"},{"id":"e6867a211c96168f16cd6a99706fc29e","title":"async/await、promise和setTimeout的执行顺序","content":"\n\n\n\n\n\n你需要提前知道的知识点\n1. 什么是进程和线程？\n2. 任务如何调度？\n\n\n\n何为进程？程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程，进程是内存分配的最小单位。\n每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。\n何为线程？有了进程后，就可以运行程序的代码了。\n运行代码的「人」称之为「线程」，线程是执行的最小单位。\n一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。\n如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。\n浏览器中的进程和线程为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。\n其中主要的进程有：\n\n浏览器进程 主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。\n网络进程 负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。\n渲染进程 渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。 默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。\n\n渲染主线程是如何工作的？渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：\n\n解析 HTML\n解析 CSS\n计算样式\n布局\n处理图层\n每秒把页面画 60 次\n执行全局 JS 代码\n执行事件处理函数\n执行计时器的回调函数\n……\n\n要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？\n渲染主线程想出了一个绝妙的主意来处理这个问题：排队\n\n\n在最开始的时候，渲染主线程会进入一个无限循环(for(;;))\n每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。\n其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务。\n\n这样一来，就可以让每个任务有条不紊的、持续的进行下去了。\n整个过程，被称之为事件循环（chrome源码里面称之为消息循环）\n\n\n\n\n\n\n阐述一下 JS 的事件循环\n事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。\n\n\n代码在执行过程中，会遇到一些无法立即处理的任务，比如：\n\n计时完成后需要执行的任务 —— setTimeout、setInterval\n网络通信完成后需要执行的任务 – XHR、Fetch\n用户操作后需要执行的任务 – addEventListener\n\n如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」\n渲染主线程承担着极其重要的工作，无论如何都不能阻塞！\n因此，浏览器选择异步来解决这个问题\n\n使用异步的方式，渲染主线程永不阻塞\n何为异步\n\n\n\n\n\n\n\n\nJS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。\n而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。\n如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。\n所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。\n在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。\nJS为何会阻碍渲染？阻塞渲染例子：\n&lt;h1&gt;Hello Javascript!&lt;&#x2F;h1&gt;\n&lt;button&gt;change&lt;&#x2F;button&gt;\n&lt;script&gt;\n  var h1 &#x3D; document.querySelector(&#39;h1&#39;);\n  var btn &#x3D; document.querySelector(&#39;button&#39;);\n\n  &#x2F;&#x2F; 死循环指定的时间\n  function delay(duration) &#123;\n    var start &#x3D; Date.now();\n    while (Date.now() - start &lt; duration) &#123;&#125;\n  &#125;\n\n  btn.onclick &#x3D; function () &#123;\n    h1.textContent &#x3D; &#39;你好，我晚到了3秒！&#39;;\n    delay(3000);\n  &#125;;\n&lt;&#x2F;script&gt;\n点击按钮后，h1被赋值后，并没有马上渲染到标签内，而是阻塞3秒后才渲染上去。\n任务有优先级吗？任务没有优先级，在消息队列中先进先出\n但消息队列是有优先级的\n\n\n\n\n\n\n根据 W3C 的最新解释\n\n每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。\n在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。\n浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行  \n随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法\n\n\n\n队列在目前 chrome 的实现中，至少包含了下面的队列：\n\n延时队列：用于存放计时器到达后的回调任务，优先级「中」\n交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」\n微队列：用户存放需要最快执行的任务，优先级「最高」\n\n\n实例演示例一\nsetTimeout(function () &#123;\n  console.log(1);\n&#125;, 0);\n\nfunction delay(duration) &#123;\n  var start &#x3D; Date.now();\n  while (Date.now() - start &lt; duration) &#123;&#125;\n&#125;\ndelay(3000);\nconsole.log(2);\n\nsetTimeout属于延时队列，这里立即执行，放到延时队列里面；\ndelay()进入死循环三秒；\n三秒过后运行console.log(2),首先输出2；\n执行完毕，再将延时队列放到主线程运行，最后输出1。\n\n结果：2 1\n例二\nfunction a() &#123;\n  console.log(1);\n  Promise.resolve().then(function () &#123;\n    console.log(2);\n  &#125;);\n&#125;\nsetTimeout(function () &#123;\n  console.log(3);\n&#125;, 0);\n\nPromise.resolve().then(a);\nconsole.log(4);\n\n\nsetTimeout属于延时队列，这里立即执行，放到延时队列里面，记为fn3；\nPromise.resolve().then(a)放到微队列，记为fn1；\n继续运行，直接输出4；\n调用微队列的fn1任务：执行a方法，直接输出1，结束fn1任务，然后把Promise.resolve().then(function () &#123;console.log(2);&#125;)放到微队列，记为fn2；\n执行fn2任务，输出2，结束fn2;\n执行延时任务fn3，输出3.\n\n结果：4 1 2 3\n例三\nasync function async1() &#123;\n\tconsole.log(&#39;async1 start&#39;);\n\tawait async2();\n\tconsole.log(&#39;asnyc1 end&#39;);\n&#125;\nasync function async2() &#123;\n\tconsole.log(&#39;async2&#39;);\n&#125;\nconsole.log(&#39;script start&#39;);\nsetTimeout(() &#x3D;&gt; &#123;\n\tconsole.log(&#39;setTimeOut&#39;);\n&#125;, 0);\nasync1();\nnew Promise(function (reslove) &#123;\n\tconsole.log(&#39;promise1&#39;);\n\treslove();\n&#125;).then(function () &#123;\n\tconsole.log(&#39;promise2&#39;);\n&#125;)\nconsole.log(&#39;script end&#39;);\n\n\n整个代码片段（script）作为一个宏任务执行console.log(&#39;script start&#39;)，输出script start；\n执行setTimeout，是一个异步动作，放入宏任务异步队列中；\n执行async1()，输出async1 start，继续向下执行；\n执行async2()，输出async2，并返回了一个promise对象，await让出了线程，把返回的promise加入了微任务异步队列，所以async1()下面的代码也要等待上面完成后继续执行;\n执行 new Promise，输出promise1，然后将resolve()放入微任务异步队列；\n执行console.log(&#39;script end&#39;)，输出script end；\n到此同步的代码就都执行完成了，然后去微任务异步队列里去获取任务\n接下来执行resolve（async2返回的promise返回的），输出了async1 end；\n然后执行resolve（new Promise的），输出了promise2；\n最后执行setTimeout，输出了settimeout。\n\n最后一个例子看起来会比较的复杂，需要理解promise和async/await。\n首先，new Promise是同步的任务，会被放到主进程中去立即执行。而.then()函数是异步任务会放到异步队列中去，那什么时候放到异步队列中去呢？当你的promise状态结束的时候，就会立即放进异步队列中去了。\n带async关键字的函数会返回一个promise对象，如果里面没有await，执行起来等同于普通函数。\nawait如同他的语意，就是在等待，等待右侧的表达式完成。此时的await会让出线程，阻塞async内后续的代码，先去执行async外的代码。等外面的同步代码执行完毕，才会执行里面的后续代码。\n","slug":"javascript/js_003","date":"2023-06-03T13:08:08.502Z","categories_index":"Javascript","tags_index":"Javascript","author_index":"Lim Forson"},{"id":"113d3c4a95b3b3fd262131044de9db93","title":"call()、apply()和bind()的区别和用法","content":"\n\n\n\n\n\n带着问题去理解\n1. 这三个方法的作用是什么？\n2. 如何使用，共同点和区别在哪里？\n3. 为什么要使用这些方法？\n4. 方法的使用场景。\n\n\n\n前言经常会看到文章有写关于 call() 和 apply() 的一些区别和使用，在学习 react 的时候也遇到用 bind() 这个方法来改变 this 的指向，所以这次就直接三者一起整合起来做一个总结。\n突然有这个想法，主要是因为这次面试的时候，被面试官问到这三个方法的区别，所以借此机会总结记录一下。\n作用所谓的作用就是其存在的意义，那三个方法存在的一样是什么？\n意义就是：改变函数执行时的上下文，也就是改变函数运行时的this指向，或者是说重新定义this这个对象。\n这也是三个方法的主要相同点。\n为何改变执行上下文举一个生活上的例子：最近网上很火的公共厨房一样，那些病人家属想给自己人煮点好吃的，但是出门在外这些都是临时的，总不能煮个饭还去买各种锅碗瓢盆，再去搭个灶台吧。所以就借用公共厨房的工具来煮菜，这样就达到的目的，又节省了开支。\n三个方法的用途也是一样，A对象有个方法，B对象因为某种原因也需要同样的方法，为了不造成代码的冗佘，B对象这边直接借用A的方法，这样既完成了需求，又减少了内存的占用。\n语法call()、apply()和bind()这三个函数的调用对象必须是一个Function\n第一个参数thisArg都是 this 的指向对象。\n\n\n\n\n\n\n\nthisArg传值注意的点\n1. 不传或者传null，undefined， 函数中的 this 指向 window 对象\n2. 值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象，如 String、Number、Boolean\n3. 传递另一个函数的函数名，函数中的this指向这个函数的引用，并不一定是该函数执行时真正的this值\n4. 传递一个对象，函数中的this指向这个对象\n\n\n\n第二个参数就有所区别了：call()和bind()之后的参数全部用逗号分隔，直接放到后面去，而apply()则是传递一个数组。bind()返回是个函数，且参数可在调用的时候直接传入，其他的都和call()一样。\n三者的参数不限定是 string 类型，允许是各种类型，包括函数 、 object 等等\nFunction.prototype.call()call(thisArg)\ncall(thisArg, arg1)\ncall(thisArg, arg1, &#x2F;* …, *&#x2F; argN)\n\nFunction.prototype.apply()apply(thisArg)\napply(thisArg, argsArray)\n\nFunction.prototype.bind()bind(thisArg)\nbind(thisArg, arg1)\nbind(thisArg, arg1, &#x2F;* …, *&#x2F; argN)\n\n举例let obj &#x3D; &#123;\n\tname: &#39;张三&#39;,\n\tage: 53,\n\tmyFunction: function(sex, from) &#123;\n\t\tconsole.log(&#39;我叫&#39; + this.name + &#39;，&#39; + sex + &#39;，今年&#39; + this.age + &#39;岁，来自&#39; + from)\n\t&#125;\n&#125;\nlet thisArg &#x3D; &#123;\n\tname: &#39;李四&#39;,\n\tage: 13\n&#125;\nobj.myFunction.call(thisArg, &#39;男&#39;, &#39;东山&#39;)\nobj.myFunction.apply(thisArg, [&#39;男&#39;, &#39;东山&#39;])\nobj.myFunction.bind(thisArg, &#39;男&#39;)(&#39;东山&#39;)\n&#x2F;&#x2F; 或者也可以这样写\nconst func &#x3D; obj.myFunction.bind(thisArg, &#39;男&#39;)\nfunc(&#39;东山&#39;)\n\n运行结果：\n我叫李四，男，今年13岁，来自东山\n我叫李四，男，今年13岁，来自东山\n我叫李四，男，今年13岁，来自东山\n\nbind()返回一个函数，里面的传值可在调用的在动态传值，但是所有的传值个数必须和函数的传参保持一致。\n使用场景继承function superClass() &#123;\n\tthis.greet &#x3D; &#39;Hello&#39;\n\tthis.print &#x3D; function(name) &#123;\n\t\tconsole.log(this.greet + &#39; &#39; + name)\n\t&#125;\n&#125;\n\nfunction subClass() &#123;\n\t&#x2F;&#x2F; 方法一\n\t&#x2F;&#x2F; superClass.call(this)\n\t&#x2F;&#x2F; 方法二\n\tsuperClass.apply(this)\n\tthis.print(&#39;Javascript&#39;)\n&#125;\nsubClass()\n&#x2F;&#x2F; Hello Javascript\nsubClass 通过 call 方法，继承了 superClass 的 print 方法和 name 变量。此外，subClass 还可以扩展自己的其他方法。\n原型扩展在原型函数上扩展和自定义方法，从而不污染原生函数。例如：我们在 Array 上扩展一个 forEach\nfunction test() &#123;\n\t&#x2F;&#x2F; 检测arguments是否为Array的实例\n\tconsole.log(\n\t\targuments instanceof Array, &#x2F;&#x2F;false\n\t\tArray.isArray(arguments) &#x2F;&#x2F;false\n\t);\n\t&#x2F;&#x2F; 判断arguments是否有forEach方法\n\tconsole.log(arguments.forEach); &#x2F;&#x2F; undefined\n\t&#x2F;&#x2F; 将数组中的forEach应用到arguments上\n\tArray.prototype.forEach.call(arguments, function(item) &#123;\n\t\tconsole.log(item); &#x2F;&#x2F; 1 2 3 4\n\t&#125;);\n&#125;\ntest(1, 2, 3, 4);\n\n用来判断类型因为 Object.prototype.toString() 方法会返回对象的类型字符串，输出 &quot;[object Object]&quot; 其中第二个 Object 是传入参数的构造函数。所以使用 call 就可以指定任意的值和结合 toString 将组成的构造函数类型返回来判断类型。同样道理换成 apply/bind 同样也可以判断\nObject.prototype.toString.call(&#39;str&#39;)   &#x2F;&#x2F; &quot;[object String]&quot;\nObject.prototype.toString.call(123)   &#x2F;&#x2F; &quot;[object Number]&quot;\nObject.prototype.toString.call(&#123;&#125;)      &#x2F;&#x2F;  &quot;[object Object]&quot;\nObject.prototype.toString.call([])      &#x2F;&#x2F;  &quot;[object Array]&quot;\n\nObject.prototype.toString.apply(&#123;&#125;)      &#x2F;&#x2F;  &quot;[object Object]&quot;\nObject.prototype.toString.apply([])      &#x2F;&#x2F;  &quot;[object Array]&quot;\n\nvar f &#x3D; Object.prototype.toString.bind(&#123;&#125;)\nf()     &#x2F;&#x2F;  &quot;[object Object]&quot;\nvar fn &#x3D; Object.prototype.toString.bind([])\nfn()   &#x2F;&#x2F;  &quot;[object Array]&quot;\n\n扩充函数赖以运行的作用域window.color &#x3D; &quot;red&quot;;  \nvar o &#x3D; &#123;color: &quot;blue&quot;&#125;;  \nfunction sayColor() &#123;  \n       alert(this.color);  \n&#125;  \nsayColor( ); &#x2F;&#x2F;red  \nsayColor.call(this);&#x2F;&#x2F;red  \nsayColor.call(window);&#x2F;&#x2F;red  \nsayColor.call(o);&#x2F;&#x2F;blue   将sayColor的this指向o\n使用call()（或apply()）来扩充作用域最大的好处，就是对象不需要与方法有任何耦合关系。\n妙用Math.max或Math.min用apply来获取数组中最大的值。\nlet max &#x3D; Math.max.apply(null, arrary)\n这时候你可能会问，为什么要这么复杂呢？直接用扩展运算符不就好了，就像这样：\nlet max &#x3D; Math.max(...arrary)\n但是这里讲的是javacript，而扩展运算符则是es6的。\n最后这些大概就是三个方法的基本用法，最主要的还是三者在实战中的使用，若还有更好的实战使用，欢迎留言告知！\n","slug":"javascript/js_002","date":"2023-06-02T15:58:21.739Z","categories_index":"Javascript","tags_index":"Javascript","author_index":"Lim Forson"},{"id":"58de8212a988128478edd77479cf970b","title":"CSS hack","content":"css hack兼容范围：IE:6.0+，FireFox:2.0+，Opera 10.0+，Sarari 3.0+，Chrome\n各浏览器hack兼容一览表\n\n\n标记\nIE6\nIE7\nIE8\nFF\nOpera\nSarari\n\n\n\n[*+&gt;&lt;]\n✔\n✔\n✘\n✘\n✘\n✘\n\n\n_\n✔\n✘\n✘\n✘\n✘\n✘\n\n\n\\9\n✔\n✔\n✔\n✘\n✘\n✘\n\n\n\\0\n✘\n✘\n✔\n✘\n✔\n✘\n\n\n@media screen and (-webkit-min-device-pixel-ratio:0){.bb {}}\n✘\n✘\n✘\n✘\n✘\n✔\n\n\n.bb , x:-moz-any-link, x:default\n✘\n✔\n✘\n✔(ff3.5及以下)\n✘\n✘\n\n\n@-moz-document url-prefix(){.bb{}}\n✘\n✘\n✘\n✔\n✘\n✘\n\n\n@media all and (min-width: 0px){.bb {}}\n✘\n✘\n✘\n✔\n✔\n✔\n\n\n* +html .bb {}\n✘\n✔\n✘\n✘\n✘\n✘\n\n\n浏览器内核\nTrident\nTrident\nTrident\nGecko\nPresto\nWebkit\n\n\n（以上**.bb**可更换为其它样式名）\n\n\n\n\n\n\n\n\n\n注意点：网上很多资料中常常把!important也作为一个hack手段，其实这是一个误区。!important常常被我们用来更改样式，而不是兼容hack。造成这个误区的原因是IE6在某些情况下不主动识别!important,以至于常常被人误用做识别IE6的hack。可是，大家注意一下，IE6只是在某些情况下不识别（ie6下，同一个大括号里对同一个样式属性定义，其中一个加important 则important标记是被忽略的，例：&#123;background:red!important; background:green;&#125; ie6下解释为背景色green，其它浏览器解释为背景色red；如果这同一个样式在不同大括号里定义，其中一个加important 则important发挥正常作用，例：div&#123;background:red!important&#125; div&#123;background:green&#125;，这时所有浏览器统一解释为背景色red。）\n实例讲解：Hack应用情境（一）适用范围：IE:6.0,IE7.0,IE8.0之间的兼容\n实例说明：\n\n\n\n\n\n\n\n\n\n此例中我们使用了渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用\\9这一标记，将IE游览器从所有情况中分离出来。接着，再次使用+将IE8和IE7、IE6分离开来，此时，我们的IE8已经独立识别。\n实例代码：\n.bb&#123;\n    height:32px;\n    background-color:#f1ee18;    &#x2F;*所有识别*&#x2F;\n    .background-color:#00deff\\9; &#x2F;*IE6、7、8识别*&#x2F;\n    +background-color:#a200ff;   &#x2F;*IE6、7识别*&#x2F;\n    _background-color:#1e0bd1;   &#x2F;*IE6识别*&#x2F;\n&#125;\n&#x2F;*一个用于展示的class为bb的div标签*&#x2F;\n&lt; div class &#x3D;&quot;bb&quot;&gt;&lt;&#x2F; div &gt;\n\n\nHack应用情境（二）适用范围：IE:6.0,IE7.0,IE8.0,Firefox之间的兼容\n实例说明：\n\n\n\n\n\n\n\n\n\n大家很容易的可以看出这是情境（一）的加强版，适用于更广泛的环境。其实情境（一）中也已经做到了把火狐与IE游览器区分开来了，现在我们要做的是把火狐从其它游览器中再次识别出来。大家仔细看下代码，大家会发现其实游览器识别是很简单的。火狐如何识别？对了，IE中对伪类支持不广泛，所以伪类是个不错的途径。(.yourClass,x:-moz-any-link, x:default)注意，这个区分伪类往往IE7也能识别，所以最好还需要把IE7单独识别出来，且此方法对ff3.6 已无效，firefox的区分可以使用@-moz-document url-prefix()&#123;&#125;\n实例代码：\n.bb&#123;\n    height:32px;\n    background-color:#f1ee18;&#x2F;*所有识别*&#x2F;\n    background-color:#00deff\\9; &#x2F;*IE6、7、8识别*&#x2F;\n    +background-color:#a200ff;&#x2F;*IE6、7识别*&#x2F;\n    _background-color:#1e0bd1;&#x2F;*IE6识别*&#x2F;\n&#125;\n.bb, x:-moz-any-link, x:default&#123;\n    background-color:#00ff00;\n&#125;&#x2F;*IE7 firefox3.5及以下 识别 *&#x2F; \n@-moz-document url-prefix()&#123;\n    .bb&#123;\n        background-color:#00ff00;\n    &#125;\n&#125;&#x2F;* 仅firefox 识别 *&#x2F; \n* +html .bb&#123;\n    background-color:#a200ff;\n&#125;&#x2F;* 仅IE7 识别 *&#x2F;\n\n&#x2F;*一个用于展示的class为bb的div标签*&#x2F;\n&lt; div class &#x3D;&quot;bb&quot;&gt;&lt;&#x2F; div &gt;\n\n\nHack应用情境（三）适用范围：IE:6.0,IE7.0,IE8.0,Firefox,Safari(Chrome)之间的兼容\n实例说明：\n\n\n\n\n\n\n\n\n\n我们现在将再次对我们的CSS进行加强了，使其能识别Safari(Chrome)游览器。这是基于它们的内核webkit来识别的，用法为@media screen and (-webkit-min-device-pixel-ratio:0)\n实例代码：\n.bb&#123;\n    height:32px;\n    background-color:#f1ee18;&#x2F;*所有识别*&#x2F;\n    background-color:#00deff\\9; &#x2F;*IE6、7、8识别*&#x2F;\n    +background-color:#a200ff;&#x2F;*IE6、7识别*&#x2F;\n    _background-color:#1e0bd1;&#x2F;*IE6识别*&#x2F;\n&#125;\n@media screen and (-webkit-min-device-pixel-ratio:0)&#123;\n    .bb&#123;\n        background-color:#f1ee18\n    &#125;\n&#125;&#123;&#125; &#x2F;*safari(Chrome) 有效 *&#x2F;\n.bb, x:-moz-any-link, x:default&#123;\n    background-color:#00ff00;\n&#125;&#x2F;*IE7 firefox3.5及以下 识别 *&#x2F; \n@-moz-document url-prefix()&#123;\n    .bb&#123;\n        background-color:#00ff00;\n    &#125;\n&#125;&#x2F;*仅firefox 识别*&#x2F; \n* +html .bb&#123;\n    background-color:#a200ff;\n&#125;&#x2F;* 仅IE7 识别 *&#x2F;\n\n&#x2F;*一个用于展示的class为bb的div标签*&#x2F;\n&lt; div class &#x3D;&quot;bb&quot;&gt;&lt;&#x2F; div &gt;\n\n\nHack应用情境（四）适用范围：IE:6.0+，FireFox:2.0+，Opera 10.0+，Sarari 3.0+，Chrome全兼容\n实例说明：\n\n\n\n\n\n\n\n\n\n实例的具体代码在下面实例代码中已经列出，具体效果如此页面的顶端部分效果，您可以通过不同游览器检测该效果。这次我们基本把所有的主流游览器都兼容了，大家来看下代码。Opera的识别有一部分归功于\\0标记，这个标记只被IE8和Opera识别，特殊的标记往往造就的是我们更广泛的hack手段。下例的代码比较完整，大家可以选择参考。\n实例代码：\n&lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-transitional.dtd&quot;&gt;\n    &lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot; lang&#x3D;&quot;gb2312&quot;&gt;\n\n    &lt;head&gt;\n        &lt;meta http-equiv&#x3D;Content-Type content&#x3D;&quot;text&#x2F;html; charset&#x3D;gb2312&quot; &#x2F;&gt;\n        &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;\n    &#x2F;***************************************** 各游览器兼容CSS **********************************************&#x2F;\n\n        .bb &#123;\n            height: 32px;\n            background-color: #f1ee18;\n            &#x2F;*所有识别*&#x2F;\n            background-color: #00deff\\9;\n            &#x2F;*IE6、7、8识别*&#x2F;\n            +background-color: #a200ff;\n            &#x2F;*IE6、7识别*&#x2F;\n            _background-color: #1e0bd1&#x2F;*IE6识别*&#x2F;\n        &#125;\n\n        @media screen and (-webkit-min-device-pixel-ratio:0) &#123;\n            .bb &#123;\n                background-color: #f1ee18\n            &#125;\n        &#125;&#123;&#125;\n        &#x2F;* Safari(Chrome) 有效 *&#x2F;\n\n        @media all and (min-width: 0px) &#123;\n            .bb &#123;\n                background-color: #f1ee18;\n                &#x2F;*opera and Safari(Chrome) and firefox*&#x2F;\n                background-color: #4cac70\\0;\n            &#125;\n            &#x2F;* 仅 Opera 有效 *&#x2F;\n        &#125;&#123;&#125;\n\n        .bb,\n        x:-moz-any-link,\n        x:default &#123;\n            background-color: #4eff00;\n            &#x2F;*IE7、Firefox3.5及以下 识别 *&#x2F;\n        &#125;\n\n        @-moz-document url-prefix() &#123;\n            .bb &#123;\n                background-color: #4eff00;\n                &#x2F;*仅 Firefox 识别 *&#x2F;\n            &#125;\n        &#125;\n\n        *+html .bb &#123;\n            background-color: #a200ff;\n        &#125;\n        &#x2F;* 仅IE7 识别 *&#x2F;\n        &#x2F;* 一般情况下 我们区分IE7 只用 +background-color 配合 _background-color 就行了 如果必须写 .bb, x:-moz-any-link, x:default 这样的代码区分 Firefox3.5及以下 则谨记此写法对IE7也有效，故在其中要再重写一次 +background-color 或者使用 * +html .bb&#123;background-color:blue;&#125; 方法仅对 IE7 有效。可使用 @-moz-document url-prefix()&#123;&#125; 方法独立区分所有 firefox *&#x2F;\n\n        .browsers td &#123;\n            width: 8%;\n            text-align: center;\n            padding: 8px;\n        &#125;\n    &#125;\n    .browsercolor &#123;\n        color: #333;\n        font-size: 18px;\n        font-weight: bold;\n    &#125;\n    .ie6 &#123;\n        background-color: #1e0bd1\n    &#125;\n    .ie7 &#123;\n        background-color: #a200ff\n    &#125;\n    .ie8 &#123;\n        background-color: #00deff\n    &#125;\n    .firefox &#123;\n        background-color: #4eff00\n    &#125;\n    .opera &#123;\n        background-color: #4cac70\n    &#125;\n    .other &#123;\n        background-color: #f1ee18;\n    &#125;\n\n    #tipTable td,\n    #tipTable th &#123;\n        border: 1px solid black;\n        width: 56px;\n        height: 16px;\n        text-align: center;\n    &#125;\n    #wordTable td &#123;\n        margin-left: 8px;\n    &#125;\n    #firefoxTip &#123;\n        display: none;\n    &#125;\n    #firefoxTip,\n    x:-moz-any-link,\n    x:default &#123;\n        display: block;\n        &#x2F;*IE7 firefox3.5及以下 识别 *&#x2F;\n\n        +display: none\n        &#x2F;*再区分一次IE7*&#x2F;\n    &#125;\n    @-moz-document url-prefix() &#123;\n        #firefoxTip &#123;\n            display: block;\n            &#x2F;*仅 firefox 识别 *&#x2F;\n        &#125;\n    &#125;\n    #ChromeTip &#123;\n        display: none;\n    &#125;\n    @media screen and (-webkit-min-device-pixel-ratio:0) &#123;\n        #ChromeTip &#123;\n            display: block;\n        &#125;\n    &#125;&#123;&#125;\n    &#x2F;* safari(Chrome) 有效 *&#x2F;\n    @media all and (min-width: 0px) &#123;\n        #ChromeTip &#123;\n            display: none\\0;\n        &#125;\n        &#x2F;* 仅 Opera 有效 *&#x2F;\n    &#125;&#123;&#125;\n        &lt;&#x2F;style&gt;\n    &lt;&#x2F;head&gt;\n\n    &lt;body&gt;\n        &lt;table class&#x3D;&quot;browsers&quot; width&#x3D;&quot;100%&quot; cellspacing&#x3D;&quot;0&quot; cellpadding&#x3D;&quot;0&quot;&gt;\n            &lt;tr&gt;\n                &lt;td&gt;IE6&lt;&#x2F;td&gt;\n                &lt;td&gt;&lt;&#x2F;td&gt;\n                &lt;td&gt;IE7&lt;&#x2F;td&gt;\n                &lt;td&gt;&lt;&#x2F;td&gt;\n                &lt;td&gt;IE8&lt;&#x2F;td&gt;\n                &lt;td&gt;&lt;&#x2F;td&gt;\n                &lt;td&gt;Firefox&lt;&#x2F;td&gt;\n                &lt;td&gt;&lt;&#x2F;td&gt;\n                &lt;td&gt;Opera&lt;&#x2F;td&gt;\n                &lt;td&gt;&lt;&#x2F;td&gt;\n                &lt;td&gt;Safari(Chrome)&lt;&#x2F;td&gt;\n                &lt;td&gt;&lt;&#x2F;td&gt;\n            &lt;&#x2F;tr&gt;\n            &lt;tr class&#x3D;&quot;browsercolor&quot;&gt;\n                &lt;td class&#x3D;&quot;ie6&quot;&gt;IE6&lt;&#x2F;td&gt;\n                &lt;td&gt;&lt;&#x2F;td&gt;\n                &lt;td class&#x3D;&quot;ie7&quot;&gt;IE7&lt;&#x2F;td&gt;\n                &lt;td&gt;&lt;&#x2F;td&gt;\n                &lt;td class&#x3D;&quot;ie8&quot;&gt;IE8&lt;&#x2F;td&gt;\n                &lt;td&gt;&lt;&#x2F;td&gt;\n                &lt;td class&#x3D;&quot;firefox&quot;&gt;Firefox&lt;&#x2F;td&gt;\n                &lt;td&gt;&lt;&#x2F;td&gt;\n                &lt;td class&#x3D;&quot;opera&quot;&gt;Opera&lt;&#x2F;td&gt;\n                &lt;td&gt;&lt;&#x2F;td&gt;\n                &lt;td class&#x3D;&quot;other&quot;&gt;Safari(Chrome)&lt;&#x2F;td&gt;\n                &lt;td&gt;&lt;&#x2F;td&gt;\n            &lt;&#x2F;tr&gt;\n        &lt;&#x2F;table&gt;\n        &lt;div class&#x3D;&quot;bb&quot;&gt;\n            &lt;span style&#x3D;&quot;display:none;display:block\\0;display:none\\9;&quot;&gt;Opera的辨别色是深绿色，Opera游览器很时髦么。&lt;&#x2F;span &gt;\n    &lt;span id&#x3D;&quot;firefoxTip&quot;&gt;Firefox的辨别色是浅绿色，Firefox是很强大的游览器。&lt;&#x2F;span &gt;\n    &lt;span id&#x3D;&quot;ChromeTip&quot;&gt;Safari和Chrome的辨别色是金黄色，Safari和Chrome使用的都是Webkit内核&lt;&#x2F;span &gt;\n    &lt;!--[if IE 8]&gt;IE8的辨别色是蓝色，新版IE8的功能可是不少呢。&lt;![endif]--&gt;\n    &lt;!--[if IE 7]&gt;IE7的辨别色是紫色，IE7还可以凑合着用！&lt;![endif]--&gt;\n    &lt;!--[if IE 6]&gt;IE6的辨别色是红色，不过，IE6可是有点落后了！&lt;![endif]--&gt;\n&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n#test&#123;   \n    width:300px;   \n    height:300px;         \n    background-color:blue;      &#x2F;*firefox*&#x2F;\n    background-color:red\\9;     &#x2F;*all ie*&#x2F;\n    background-color:yellow\\0;  &#x2F;*ie8*&#x2F;\n    +background-color:pink;     &#x2F;*ie7*&#x2F;\n    _background-color:orange;   &#x2F;*ie6*&#x2F;\n&#125;  \n:root #test &#123;\n    background-color:purple\\9;\n&#125;  &#x2F;*ie9*&#x2F;\n@media all and (min-width:0px)&#123;\n    #test &#123;\n        background-color:black\\0;\n    &#125;\n&#125;  &#x2F;*opera*&#x2F;\n@media screen and (-webkit-min-device-pixel-ratio:0)&#123;\n    #test &#123;\n        background-color:gray;\n    &#125; \n&#125; &#x2F;*chrome and safari*&#x2F;\n\n\n","slug":"css/css_002","date":"2023-05-26T06:48:44.939Z","categories_index":"CSS","tags_index":"CSS,CSS HACK","author_index":"Lim Forson"},{"id":"d4026f51002d22aa52a2d58bbc35f9b0","title":"你会用ES6，那你到是用啊！","content":"\n\n\n\n\n\n\n\n\n之前在 稀土掘金 看到过这样一篇文章 你会用ES6，那你倒是用啊！，觉得作者的写作方法很是幽默，让人看起来不会很是乏味，里面讲解的知识也很是通俗易懂，容易吸收。我这里就直接简单的将作者的原文做一次引用，如果涉及侵权需要删除，可单独联系！\n\n不是标题党，这是一位leader在一次代码评审会对小组成员发出的“怒吼”，原因是在代码评审中发现很多地方还是采用ES5的写法，也不是说用ES5写法不行，会有BUG，只是造成代码量增多，可读性变差而已。\n恰好，这位leader有代码洁癖，面对3~5年经验的成员，还写这种水平的代码，极为不满，不断对代码进行吐槽。不过对于他的吐槽，我感觉还是有很大收获的，故就把leader的吐槽记录下来，分享给掘友们，觉得有收获点个赞，有错误的或者更好的写法，非常欢迎在评论中留言。\nps：ES5之后的JS语法统称ES6！！！\n一、关于取值的吐槽取值在程序中非常常见，比如从对象obj中取值。\nconst obj &#x3D; &#123;\n    a:1,\n    b:2,\n    c:3,\n    d:4,\n    e:5,\n&#125;\n吐槽:\nconst a &#x3D; obj.a;\nconst b &#x3D; obj.b;\nconst c &#x3D; obj.c;\nconst d &#x3D; obj.d;\nconst e &#x3D; obj.e;\n或者\nconst f &#x3D; obj.a + obj.d;\nconst g &#x3D; obj.c + obj.e;\n吐槽：“不会用ES6的解构赋值来取值吗？5行代码用1行代码搞定不香吗？直接用对象名加属性名去取值，要是对象名短还好，很长呢？搞得代码中到处都是这个对象名。”\n改进：\nconst &#123;a,b,c,d,e&#125; &#x3D; obj;\nconst f &#x3D; a + d;\nconst g &#x3D; c + e;\n反驳\n不是不用ES6的解构赋值，而是服务端返回的数据对象中的属性名不是我想要的，这样取值，不是还得重新创建个遍历赋值。\n吐槽\n看来你对ES6的解构赋值掌握的还是不够彻底。如果想创建的变量名和对象的属性名不一致，可以这么写：\nconst &#123;a:a1&#125; &#x3D; obj;\nconsole.log(a1); &#x2F;&#x2F; 1\n\n补充\nES6的解构赋值虽然好用。但是要注意解构的对象不能为undefined、null。否则会报错，故要给被解构的对象一个默认值。\nconst &#123;a,b,c,d,e&#125; &#x3D; obj || &#123;&#125;;\n\n二、关于合并数据的吐槽比如合并两个数组，合并两个对象。\nconst a &#x3D; [1,2,3];\nconst b &#x3D; [1,5,6];\nconst c &#x3D; a.concat(b);&#x2F;&#x2F;[1,2,3,1,5,6]\n\nconst obj1 &#x3D; &#123;\n  a:1,\n&#125;\nconst obj2 &#x3D; &#123;\n  b:1,\n&#125;\nconst obj &#x3D; Object.assign(&#123;&#125;, obj1, obj2);&#x2F;&#x2F;&#123;a:1,b:1&#125;\n吐槽\nES6的扩展运算符是不是忘记了，还有数组的合并不考虑去重吗？\n改进\nconst a &#x3D; [1,2,3];\nconst b &#x3D; [1,5,6];\nconst c &#x3D; [...new Set([...a,...b])];&#x2F;&#x2F;[1,2,3,5,6]\n\nconst obj1 &#x3D; &#123;\n  a:1,\n&#125;\nconst obj2 &#x3D; &#123;\n  b:1,\n&#125;\nconst obj &#x3D; &#123;...obj1,...obj2&#125;;&#x2F;&#x2F;&#123;a:1,b:1&#125;\n\n三、关于拼接字符串的吐槽const name &#x3D; &#39;小明&#39;;\nconst score &#x3D; 59;\nlet result &#x3D; &#39;&#39;;\nif(score &gt; 60)&#123;\n  result &#x3D; &#96;$&#123;name&#125;的考试成绩及格&#96;; \n&#125;else&#123;\n  result &#x3D; &#96;$&#123;name&#125;的考试成绩不及格&#96;; \n&#125;\n\n吐槽\n像你们这样用ES6字符串模板，还不如不用，你们根本不清楚在$&#123;&#125;中可以做什么操作。在${}中可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。\n改进\nconst name &#x3D; &#39;小明&#39;;\nconst score &#x3D; 59;\nconst result &#x3D; &#96;$&#123;name&#125;$&#123;score &gt; 60?&#39;的考试成绩及格&#39;:&#39;的考试成绩不及格&#39;&#125;&#96;;\n\n四、关于if中判断条件的吐槽if(\n    type &#x3D;&#x3D; 1 ||\n    type &#x3D;&#x3D; 2 ||\n    type &#x3D;&#x3D; 3 ||\n    type &#x3D;&#x3D; 4 ||\n)&#123;\n   &#x2F;&#x2F;...\n&#125;\n\n吐槽\nES6中数组实例方法includes会不会使用呢？\n改进\nconst condition &#x3D; [1,2,3,4];\n\nif( condition.includes(type) )&#123;\n   &#x2F;&#x2F;...\n&#125;\n\n五、关于列表搜索的吐槽在项目中，一些没分页的列表的搜索功能由前端来实现，搜索一般分为精确搜索和模糊搜索。搜索也要叫过滤，一般用filter来实现。\nconst a &#x3D; [1,2,3,4,5];\nconst result &#x3D; a.filter( \n  item &#x3D;&gt;&#123;\n    return item &#x3D;&#x3D;&#x3D; 3\n  &#125;\n)\n\n吐槽\n如果是精确搜索不会用ES6中的find吗？性能优化懂么，find方法中找到符合条件的项，就不会继续遍历数组\n改进\nconst a &#x3D; [1,2,3,4,5];\nconst result &#x3D; a.find( \n  item &#x3D;&gt;&#123;\n    return item &#x3D;&#x3D;&#x3D; 3\n  &#125;\n)\n\n六、关于扁平化数组的吐槽一个部门JSON数据中，属性名是部门id，属性值是个部门成员id数组集合，现在要把有部门的成员id都提取到一个数组集合中。\nconst deps &#x3D; &#123;\n&#39;采购部&#39;:[1,2,3],\n&#39;人事部&#39;:[5,8,12],\n&#39;行政部&#39;:[5,14,79],\n&#39;运输部&#39;:[3,64,105],\n&#125;\nlet member &#x3D; [];\nfor (let item in deps)&#123;\n    const value &#x3D; deps[item];\n    if(Array.isArray(value))&#123;\n        member &#x3D; [...member,...value]\n    &#125;\n&#125;\nmember &#x3D; [...new Set(member)]\n吐槽\n获取对象的全部属性值还要遍历吗？Object.values忘记了吗？还有涉及到数组的扁平化处理，为啥不用ES6提供的flat方法呢，还好这次的数组的深度最多只到2维，还要是遇到4维、5维深度的数组，是不是得循环嵌套循环来扁平化？\n改进\nconst deps &#x3D; &#123;\n    &#39;采购部&#39;:[1,2,3],\n    &#39;人事部&#39;:[5,8,12],\n    &#39;行政部&#39;:[5,14,79],\n    &#39;运输部&#39;:[3,64,105],\n&#125;\nlet member &#x3D; Object.values(deps).flat(Infinity);\n\n其中使用Infinity作为flat的参数，使得无需知道被扁平化的数组的维度。\n补充: flat方法不支持IE浏览器。\n七、关于获取对象属性值的吐槽const name &#x3D; obj &amp;&amp; obj.name;\n吐槽\nES6中的可选链操作符会使用么？\n改进\nconst name &#x3D; obj?.name;\n\n八、关于添加对象属性的吐槽当给对象添加属性时，如果属性名是动态变化的，该怎么处理。\nlet obj &#x3D; &#123;&#125;;\nlet index &#x3D; 1;\nlet key &#x3D; &#96;topic$&#123;index&#125;&#96;;\nobj[key] &#x3D; &#39;话题内容&#39;;\n\n吐槽\n为何要额外创建一个变量。不知道ES6中的对象属性名是可以用表达式吗？\n改进\nlet obj &#x3D; &#123;&#125;;\nlet index &#x3D; 1;\nobj[&#96;topic$&#123;index&#125;&#96;] &#x3D; &#39;话题内容&#39;;\n\n九、关于输入框非空的判断在处理输入框相关业务时，往往会判断输入框未输入值的场景。\nif(value !&#x3D;&#x3D; null &amp;&amp; value !&#x3D;&#x3D; undefined &amp;&amp; value !&#x3D;&#x3D; &#39;&#39;)&#123;\n    &#x2F;&#x2F;...\n&#125;\n\n吐槽\nES6中新出的空值合并运算符了解过吗，要写那么多条件吗？\nif((value??&#39;&#39;) !&#x3D;&#x3D; &#39;&#39;)&#123;\n  &#x2F;&#x2F;...\n&#125;\n\n十、关于异步函数的吐槽异步函数很常见，经常是用 Promise 来实现。\nconst fn1 &#x3D; () &#x3D;&gt;&#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      resolve(1);\n    &#125;, 300);\n  &#125;);\n&#125;\nconst fn2 &#x3D; () &#x3D;&gt;&#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      resolve(2);\n    &#125;, 600);\n  &#125;);\n&#125;\nconst fn &#x3D; () &#x3D;&gt;&#123;\n   fn1().then(res1 &#x3D;&gt;&#123;\n      console.log(res1);&#x2F;&#x2F; 1\n      fn2().then(res2 &#x3D;&gt;&#123;\n        console.log(res2)\n      &#125;)\n   &#125;)\n&#125;\n\n吐槽\n如果这样调用异步函数，不怕形成地狱回调啊！\n改进\nconst fn &#x3D; async () &#x3D;&gt;&#123;\n  const res1 &#x3D; await fn1();\n  const res2 &#x3D; await fn2();\n  console.log(res1);&#x2F;&#x2F; 1\n  console.log(res2);&#x2F;&#x2F; 2\n&#125;\n补充\n但是要做并发请求时，还是要用到Promise.all()。\nconst fn &#x3D; () &#x3D;&gt;&#123;\n   Promise.all([fn1(),fn2()]).then(res &#x3D;&gt;&#123;\n       console.log(res);&#x2F;&#x2F; [1,2]\n   &#125;) \n&#125;\n\n如果并发请求时，只要其中一个异步函数处理完成，就返回结果，要用到Promise.race()。\n","slug":"es6/es6_001","date":"2023-05-26T02:06:09.343Z","categories_index":"ES6","tags_index":"ES6","author_index":"Lim Forson"},{"id":"b2cc4378449d336ad426ce0756b96b31","title":"H5中简单的PDF文件预览","content":"\n\n\n在web页面中预览pdf文件的方式有多种，有的是直接打开，有的是借助不同的封装插件进行预览，这里介绍一个极其简单的预览插件。\n使用到的插件\npdfh5\naxios\n\n安装npm i pdfh5 --save\n\n导入插件import Pdfh5 from &#39;pdfh5&#39;\nimport &#39;pdfh5&#x2F;css&#x2F;pdfh5.css&#39;\nimport axios from &#39;axios&#39;\n\n定义变量pdfh5: null,\npdfUrl: &#39;&#39;\n\n请求和渲染axios.get(this.pdfUrl, &#123;\n  responseType: &#39;arraybuffer&#39;\n&#125;).then(res &#x3D;&gt; &#123;\n  this.pdfh5 &#x3D; new Pdfh5(&#39;#render-box&#39;, &#123;\n    data: res.data\n  &#125;)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n注：#render-box 为PDF渲染区域。本地PDF链接需做跨域处理。\n","slug":"plugins/plugin_001","date":"2023-05-24T02:54:44.539Z","categories_index":"Plugins","tags_index":"pdfh5","author_index":"Lim Forson"},{"id":"58f8583587853300427967dcc2c71efb","title":"JQuery 插件封装","content":"\n\n\njQuery 的开发方式\n通过$.extend()来扩展jQuery\n通过$.fn向jQuery添加新方法\n通过$.widget()应用jQuery UI的部件工厂方式创建\n\n写在哪里写插件一般都是单独的一个文件出来，然后可重复的供他人调用。由于插件依赖的是jQuery，所以在写插件的时候需要避免一些不必要的冲突和一些兼容的问题，所以就有了一下的一种安全的结构。\n;(function($,window,document,undefined)&#123;\n    &#x2F;&#x2F;CODE HERE\n&#125;)(jQuery,window,document);\n\n$.extend()\n\n\n\n\n\n\n\n\n第一种方式很简单，仅仅是在jQuery命名空间或者理解成jQuery身上添加了一个静态方法而以。所以我们调用通过$.extend()添加的函数时直接通过$符号调用（$.myfunction()）而不需要选中DOM元素($(‘#example’).myfunction())。\n例子：\n$.extend(&#123;\n    sayHello: function(name) &#123;\n        console.log(&#39;Hello,&#39; + (name ? name : &#39;Dude&#39;) + &#39;!&#39;);\n    &#125;\n&#125;)\n$.sayHello(); &#x2F;&#x2F;调用\n$.sayHello(&#39;Linfs&#39;); &#x2F;&#x2F;带参调用\n\n运行结果：\n\n\n\n\n\n\n\n\n\nHello,Dude!Hello,Linfs\n第一种方式很简单，但是也有很大的局限性。这种方式无法利用jQuery强大的选择器带来的便利，要处理DOM元素以及将插件更好地运用于所选择的元素身上，还是需要使用第二种开发方式\n$.fn基本格式$.fn.pluginName &#x3D; function()&#123;\n    &#x2F;&#x2F;CODE HERE\n&#125;\n\n简单的例子给链接上色$.fn.greenify &#x3D; function() &#123;\n    this.css( &quot;color&quot;, &quot;green&quot; );\n&#125;;\n&#x2F;&#x2F; 调用\n$( &quot;a&quot; ).greenify();\n\n通过以上的插件方法就可以把所有的链接变成绿色了。\n插件里面的this主要代表的就是所选元素的一个集合，也就是$(&quot;a&quot;)，即this&#x3D;$(“a”),相当于$(&quot;a&quot;).css( &quot;color&quot;, &quot;green&quot; )。\n上面说了this是所选元素的一个集合，但是有时候并不需要对所有的元素进行同样的操作，所以接下来将处理集合中的每个元素。\neach()使用jQuery中的each()对集合中的元素进行操作，这时候each()内部的this指带的是普通的DOM元素了，如果需要调用jQuery的方法那就需要用$来重新包装一下\n;(function($,window,document,undefined)&#123;\n    var colorArr &#x3D; [&quot;#3793e2&quot;,&quot;#5ab55a&quot;,&quot;#cc3f65&quot;,&quot;#a526cb&quot;];\n    $.fn.changeColor &#x3D; function()&#123;\n        this.each(function()&#123;\n            var i &#x3D; Math.round(Math.random()*(colorArr.length-1));\n            $(this).css(&#123;&quot;color&quot;:colorArr[i]&#125;);\n        &#125;);\n    &#125;\n&#125;)(jQuery,window,document);\n\n&#x2F;&#x2F;调用\n$(&quot;a&quot;).changeColor();\n\n运行结果：\n这样就随机的给每一条链接配上颜色，而不是同样的颜色。\n支持链式调用看到上面的结果，还不是很美观，如果能去掉下划线就ok了。这时候要在原来的基础上调用其它的方法将下划线出去掉，就要用到链式调用了。如果按照刚才的写法是无法完成链式调用的，要让插件不打破这种链式调用，只需return一下即可。\n;(function($,window,document,undefined)&#123;\n    var colorArr &#x3D; [&quot;#3793e2&quot;,&quot;#5ab55a&quot;,&quot;#cc3f65&quot;,&quot;#a526cb&quot;];\n    $.fn.changeColor &#x3D; function()&#123;\n        return this.each(function()&#123;\n            var i &#x3D; Math.round(Math.random()*(colorArr.length-1));\n            $(this).css(&#123;&quot;color&quot;:colorArr[i]&#125;);\n        &#125;);\n    &#125;\n&#125;)(jQuery,window,document);\n\n&#x2F;&#x2F;调用\n$(&quot;a&quot;).changeColor().css(&quot;text-decoration&quot;,&quot;none&quot;);\n\n运行结果：\n接收参数这是后你会发现，简单的改变字体的颜色已经满足不了你的需求了，你需要改变更多的元素属性，这时候我们设置更多的属性接收不同的参数来满足需求。看例子：\n;(function($,window,document,undefined)&#123;\n    $.fn.changeColor &#x3D; function(options)&#123;\n        var defauts &#x3D; &#123;\n          &quot;colorArr&quot;:[&#39;#3793e2&#39;,&#39;#5ab55a&#39;,&#39;#cc3f65&#39;,&#39;#a526cb&#39;],\n          &quot;backgroundColor&quot;:&quot;#eee&quot;,\n          &quot;fontSize&quot;:&quot;14px&quot;\n        &#125;;\n&#x2F;&#x2F;      var settings &#x3D; $.extend(defauts,options);\n        var settings &#x3D; $.extend(&#123;&#125;,defauts,options);\n        return this.each(function()&#123;\n            var i &#x3D; Math.round(Math.random()*(settings.colorArr.length-1));\n            $(this).css(&#123;\n                &quot;color&quot;:settings.colorArr[i],\n                &quot;backgroundColor&quot;:settings.backgroundColor,\n                &quot;fontSize&quot;:settings.fontSize\n            &#125;);\n        &#125;);\n    &#125;\n&#125;)(jQuery,window,document);\n&#x2F;&#x2F; 使用默认参数的调用\n$(&quot;a&quot;).changeColor().css(&quot;text-decoration&quot;,&quot;none&quot;);\n&#x2F;&#x2F; 修改默认参数的调用\n$(&quot;a&quot;).changeColor(&#123;\n    &quot;colorArr&quot;:[&#39;#3793e2&#39;,&#39;#5ab55a&#39;,&#39;#cc3f65&#39;,&#39;#a526cb&#39;,&quot;#fcbe16&quot;,&quot;#0afafa&quot;],\n    &quot;backgroundColor&quot;:&quot;#000&quot;,\n    &quot;fontSize&quot;:&quot;16px&quot;\n&#125;).css(&quot;text-decoration&quot;,&quot;none&quot;);\n\n\n\n\n使用默认参数的调用\n修改默认参数的调用\n\n\n\n\n\n\n\n看完代码会发现有两种接收参数的方式。\n\nvar settings = $.extend(defauts,options);这种方式有个特点，就是options带进来的值会覆盖掉defaults的默认值，这样如果需要再调用默认值的话会变成传进来的值。\nvar settings = $.extend(&#123;&#125;,defauts,options);这个多了个对象，这样所有值被合并到这个空对象上，保护了插件里面的默认值，可以保证传进来的值覆盖原来的默认值。\n\n所以，一般来说都会使用第二种方式传递参数。\n####面向对象插件开发为什么要有面向对象的思维，因为如果不这样，你可能需要一个方法的时候就去定义一个function，当需要另外一个方法的时候，再去随便定义一个function，同样，需要一个变量的时候，毫无规则地定义一些散落在代码各处的变量。\n还是老问题，不方便维护，也不够清晰。当然，这些问题在代码规模较小时是体现不出来的。\n如果将需要的重要变量定义到对象的属性上，函数变成对象的方法，当我们需要的时候通过对象来获取，一来方便管理，二来不会影响外部命名空间，因为所有这些变量名还有方法名都是在对象内部。\n;(function($,window,document,undefined)&#123;\n    &#x2F;&#x2F; 变量声明\n    var pluginName &#x3D; &quot;changecolor&quot;,\n        defauts &#x3D; &#123;\n            &quot;colorArr&quot;:[&#39;#3793e2&#39;,&#39;#5ab55a&#39;,&#39;#cc3f65&#39;,&#39;#a526cb&#39;],\n            &quot;backgroundColor&quot;:&quot;#eee&quot;,\n            &quot;fontSize&quot;:&quot;14px&quot;\n        &#125;;\n    &#x2F;&#x2F; 构造函数\n    function changeColor(ele,options)&#123;\n        this.element &#x3D; ele;\n        this.settings &#x3D; $.extend(&#123;&#125;,defauts,options);\n        this.changecolor();\n        this.hover();\n    &#125;;\n    changeColor.prototype&#x3D; &#123;\n        changecolor: function()&#123;\n            var i &#x3D; Math.round(Math.random()*(this.settings.colorArr.length-1)),\n                arr &#x3D; this.settings.colorArr[i],\n                bg &#x3D; this.settings.backgroundColor,\n                fz &#x3D; this.settings.fontSize;\n            return $(this.element).each(function()&#123;\n                $(this).css(&#123;\n                    &quot;color&quot;:arr,\n                    &quot;backgroundColor&quot;:bg,\n                    &quot;fontSize&quot;:fz\n                &#125;);\n            &#125;);\n        &#125;,\n        hover: function()&#123;\n            $(this.element).each(function()&#123;\n               $(this).hover(function()&#123;\n                   $(this).css(&quot;color&quot;,&quot;#fff&quot;);\n               &#125;); \n            &#125;);\n        &#125;\n    &#125;;\n    $.fn[pluginName] &#x3D; function(options)&#123;\n        this.each(function()&#123;\n            if(!$.data(this,pluginName))&#123;\n                $.data(this,pluginName,new changeColor(this,options));\n            &#125;\n        &#125;);\n        return this;\n    &#125;\n&#125;)(jQuery,window,document);","slug":"jquery/jq_001","date":"2023-05-23T02:35:56.520Z","categories_index":"JQuery","tags_index":"JQuery","author_index":"Lim Forson"},{"id":"1ff54552393e0b2b43253a5d68ca54e8","title":"apply()和call()的使用","content":"apply()和call()作用call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。\n方法定义call 和 apply二者的作用完全一样，只是接受参数的方式不太一样。\n方法&#x2F;*apply()方法*&#x2F;\nfunction.apply(thisObj[, argArray])\n\n&#x2F;*call()方法*&#x2F;\nfunction.call(thisObj[, arg1[, arg2[, [,...argN]]]]);\n\n定义apply：应用某一对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。\ncall：调用一个对象的一个方法，以另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。\n\n\n\n\n\n\n\n\n\nPS:A对象将代替B类里的this对象\n异同之处相同都“可以用来代替另一个对象调用一个方法，将一个函数的对象上下文从初始的上下文改变为由thisObj指定的新对象”。\n不同apply：最多只能有两个参数——新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeError。如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数。\ncall：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表。这个方法主要用在js对象各方法相互调用的时候，使当前this实例指针保持一致，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么 Global 对象被用作thisObj。\n实际上，apply和call的功能是一样的，只是传入的参数列表形式不同。\n严格模式和非严格模式非严格模式在非严格模式下当我们第一个参数传递为null或undefined时，函数体内的this会指向默认的宿主对象，在浏览器中则是window\n&#39;use strict&#39;\nvar test &#x3D; function()&#123;\n    console.log(this&#x3D;&#x3D;&#x3D;window);\n&#125;\ntest.apply(null);&#x2F;&#x2F;true\ntest.call(undefined);&#x2F;&#x2F;true\n\n严格模式在ECMAScript 5的strict模式下，这种情况下的this已经被规定为不会指向全局对象，而是undefined\n&#39;use strict&#39;\nvar test &#x3D; function()&#123;\n    console.log(this&#x3D;&#x3D;&#x3D;window);\n    console.log(this&#x3D;&#x3D;&#x3D;undefined);\n&#125;\ntest.apply(null);\ntest.call(undefined);\n&#x2F;&#x2F;result:false false false true\n\n用法借用别人的方法此时foo中的logName方法将被bar引用 ，this指向了bar\n&#39;use strict&#39;\nvar Animal &#x3D; &#123;\n    name:&quot;goat&quot;,\n    logName:function()&#123;\n      console.log(this.name);\n    &#125;\n&#125;\nvar Sheep &#x3D; &#123;\n    name:&quot;sheep&quot;\n&#125;\nAnimal.logName.apply(Sheep);\nAnimal.logName.call(Sheep);\n&#x2F;&#x2F; result:\n&#x2F;&#x2F; &gt; sheep\n&#x2F;&#x2F; &gt; sheep\n\n实现继承\n\n\n\n\n\n\n\n\n单一继承\n&#39;use strict&#39;\nfunction Animal(name)&#123;\n    this.name &#x3D; name;\n    this.logName &#x3D; function()&#123;\n      console.log(this.name);\n    &#125;\n&#125;\nfunction Sheep(name)&#123;\n    Animal.call(this,name);\n    &#x2F;&#x2F;apply的用法\n    &#x2F;&#x2F;Animal.apply(this,[name]);\n&#125;\nvar sheep &#x3D; new Sheep(&quot;sheep&quot;);\nsheep.logName();\n\n\n\n\n\n\n\n\n\n多重继承\n&#39;use strict&#39;\nfunction Cat()&#123;\n    this.logName &#x3D; function(name)&#123;\n      console.log(name);\n    &#125;\n&#125;;\nfunction Dog()&#123;\n    this.showName &#x3D; function(name)&#123;\n      console.log(name);\n    &#125;\n&#125;;\nfunction Animal()&#123;\n    Cat.call(this);\n    Dog.call(this);\n    &#x2F;&#x2F;Cat.apply(this);\n    &#x2F;&#x2F;Dog.apply(this);\n&#125;;\nvar a &#x3D; new Animal();\na.logName(&quot;Cat&quot;);\na.showName(&quot;Dog&quot;);\n实际中的问题在实际开发中，经常会遇到this指向被不经意改变的场景。有一个局部的fun方法，fun被作为普通函数调用时，fun内部的this指向了window，但我们往往是想让它指向该#test节点，见如下代码：‘use strict’\nwindow.id&#x3D;&quot;window&quot;;\ndocument.querySelector(&#39;#test&#39;).onclick &#x3D; function()&#123;\n  console.log(this.id);&#x2F;&#x2F;test\n  var fun &#x3D; function()&#123;\n    console.log(this.id);\n  &#125;\n  fun();&#x2F;&#x2F;window\n&#125;\n\n在严格模式下，就会出现问题。\n\n\n\n\n\n\n\n\n\ntest15:33:34.798 index.js:7 Uncaught TypeError: Cannot read property ‘id’ of undefined at fun (index.js:7) at HTMLButtonElement.document.querySelector.onclick (index.js:9)\n使用call,apply我们就可以轻松的解决这种问题了\n&#39;use strict&#39;\nwindow.id&#x3D;&quot;window&quot;;\ndocument.querySelector(&#39;#test&#39;).onclick &#x3D; function()&#123;\n  console.log(this.id);&#x2F;&#x2F;test\n  var fun &#x3D; function()&#123;\n    console.log(this.id);\n  &#125;\n  fun.call(this);&#x2F;&#x2F;test\n  fun.apply(this);&#x2F;&#x2F;test\n&#125;\n\n当然你也可以这样做，不过在ECMAScript 5的strict模式下，这种情况下的this已经被规定为不会指向全局对象，而是undefined：\n&#39;use strict&#39;\nwindow.id&#x3D;&quot;window&quot;;\ndocument.querySelector(&#39;#test&#39;).onclick &#x3D; function()&#123;\n  var that &#x3D; this;\n  console.log(this.id);&#x2F;&#x2F;test\n  var fun &#x3D; function()&#123;\n    console.log(that.id);\n  &#125;\n  fun();&#x2F;&#x2F;test\n&#125;\n\n更多巧妙的用法数组类通常把具有一下条件的对象称为数组类  \n\n具有length属性  \n按索引方式存储数据  \n不具有数组的push,pop等方法常见类数组有 arguments,NodeList!\n\n(function()&#123;\n    Array.prototype.push.call(arguments,4);\n    console.log(arguments);&#x2F;&#x2F;[1, 2, 3, 4]\n&#125;)(1,2,3);\n\n这样就往arguments中push一个4进去了\n同样push方法没有提供push一个数组,但是它提供了push(param1,param,…paramN) 所以同样也可以通过apply来装换一下这个数组,即:\nvar arr1&#x3D;new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;); \nvar arr2&#x3D;new Array(&quot;4&quot;,&quot;5&quot;,&quot;6&quot;); \nArray.prototype.push.apply(arr1,arr2); \nconsole.log(arr1);&#x2F;&#x2F;[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;]\n\n求数组中的最大(小)值因为Math.max不支持Math.max([param1,param2])也就是数组，但是它支持Math.max(param1,param2...)，所以可以根据apply的特点来解决 var max=Math.max.apply(null,array)，这样就轻易的可以得到一个数组中的最大项（apply会将一个数组转换为一个参数接一个参数的方式传递给方法）\n这块在调用的时候第一个参数给了null，这是因为没有对象去调用这个方法，我只需要用这个方法帮我运算，得到返回的结果就行，所以直接传递了一个null过去。\nvar arr &#x3D; [2,3,54,32,6,99,34];\nvar  maxVal &#x3D; Math.max.apply(null,arr);\nconsole.log(maxVal);&#x2F;&#x2F;99\n\n判断类型console.log(Object.prototype.toString.call(123)) &#x2F;&#x2F;[object Number]\nconsole.log(Object.prototype.toString.call(&#39;123&#39;)) &#x2F;&#x2F;[object String]\nconsole.log(Object.prototype.toString.call(undefined)) &#x2F;&#x2F;[object Undefined]\nconsole.log(Object.prototype.toString.call(true)) &#x2F;&#x2F;[object Boolean]\nconsole.log(Object.prototype.toString.call(&#123;&#125;)) &#x2F;&#x2F;[object Object]\nconsole.log(Object.prototype.toString.call([])) &#x2F;&#x2F;[object Array]\nconsole.log(Object.prototype.toString.call(function()&#123;&#125;)) &#x2F;&#x2F;[object Function]\n\n\n","slug":"javascript/js_001","date":"2023-05-23T02:29:30.251Z","categories_index":"Javascript","tags_index":"Javascript","author_index":"Lim Forson"},{"id":"5b87b1e754ccdf31f0f89626f68fdd11","title":"CSS RESET","content":"cssreset\n\n\n\n\n\n\n\n\n有margin值的元素有：\nbody h1 h2 h3 h4 h5 h6 p blockquote pre hr figure dl dd ul ol fieldset menu\n\n\n\n\n\n\n\n\n\n有padding值的元素有:\nul ol button th td fieldset legend textarea menu\n\n\n\n\n\n\n\n\n\n有border值的元素有：\nhr input button fieldset textarea\n虽然这些都有border,不过个人觉得没有必要进行重置。\nbody,h1,h2,h3,h4,h5,h6,p,blockquote,pre,hr,figure, dl,dd,ul,ol,fieldset,menu&#123;margin:0&#125;\nul,ol,button,th,td,fieldset,legend,textarea,menu&#123;padding:0&#125;\n\nHTML5新标签针对旧浏览器重置header,footer,section,article,aside,nav,hgroup,address,figure,figcaption,menu,details&#123;display:block;&#125;\n\n其它元素样式重置bodybody&#123;\n  line-height:1;\n&#125;\n\n字体大小h1,h2,h3,h4,h5,h6,pre&#123;\n  font-size:100%;\n&#125;\n\n列表ol,ul&#123;\n  list-style:none;\n&#125;\n\n表格table &#123;\n  border-collapse: collapse;\n  border-spacing: 0;\n&#125;\n\n链接:link,:visited&#123;\n  text-decoration:none;\n&#125;\n\n金手指a,button,input[type&#x3D;&#39;button&#39;]&#123;\n  cursor:pointer;\n&#125;\n\n利用伪类清除浮动.clearfix:after &#123;\n  content:&quot;.&quot;;\n  display:block;\n  height:0;\n  visibility:hidden;\n  clear:both;\n&#125;\n.clearfix &#123;\n  *zoom:1;\n&#125;\n\n\n查看 cssreset文件说明\n更多css规范 NEC\n","slug":"css/css_001","date":"2023-05-22T12:29:21.397Z","categories_index":"CSS","tags_index":"CSS","author_index":"Lim Forson"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-05-21T14:17:31.890Z","categories_index":"Hexo","tags_index":"Hexo","author_index":"Lim Forson"}]